commit 8f46d59abdedd0eec4940c78850f94392c207af2
Author: nidefawl <nidefawl@craftland.org>
Date:   Thu Apr 2 08:22:22 2015 +0200

    more refactoring. all files in main package now

diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
diff --git a/build.gradle b/build.gradle
old mode 100644
new mode 100755
diff --git a/credits b/credits
old mode 100644
new mode 100755
diff --git a/gradle.properties b/gradle.properties
old mode 100644
new mode 100755
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
old mode 100644
new mode 100755
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
old mode 100644
new mode 100755
diff --git a/gradlew.bat b/gradlew.bat
old mode 100644
new mode 100755
diff --git a/license b/license
old mode 100644
new mode 100755
diff --git a/src/main/java/littleMaidMobX/ClientHelper.java b/src/main/java/littleMaidMobX/ClientHelper.java
new file mode 100755
index 0000000..326529a
--- /dev/null
+++ b/src/main/java/littleMaidMobX/ClientHelper.java
@@ -0,0 +1,192 @@
+package littleMaidMobX;
+
+import java.util.Random;
+
+import littleMaidMobX.models.ModelBase;
+import littleMaidMobX.models.ModelBoxBase;
+import littleMaidMobX.models.ModelRenderer;
+import littleMaidMobX.network.NetConstants;
+import littleMaidMobX.network.Message;
+import littleMaidMobX.network.Network;
+import littleMaidMobX.textures.TextureManager;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.OpenGlHelper;
+import net.minecraft.client.renderer.RenderHelper;
+import net.minecraft.client.renderer.entity.Render;
+import net.minecraft.client.renderer.entity.RenderManager;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.projectile.EntityArrow;
+import net.minecraft.util.MathHelper;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.world.World;
+
+import org.lwjgl.opengl.GL11;
+
+public class ClientHelper {
+
+//	public static ItemRenderer itemRenderer;
+
+	/**
+	 * 初期化時実行コード
+	 */
+/*
+	public static void init() {
+		try {
+			// TODO: バージョンアップ時には確認すること
+			List lresourcePacks = (List)ModLoader.getPrivateValue(Minecraft.class, Minecraft.getMinecraft(), 63);
+			lresourcePacks.add(new ModOldResourcePack(mod_MMMLib.class));
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	public static void setItemRenderer() {
+		if (itemRenderer == null) {
+			itemRenderer = new ItemRenderer(Helper.mc);
+		}
+		if (!(Helper.mc.entityRenderer.itemRenderer instanceof ItemRenderer)) {
+			mod_LMM_LittleMaidMobX.Debug("replace entityRenderer.itemRenderer.");
+			Helper.mc.entityRenderer.itemRenderer = itemRenderer;
+		}
+		if (!(RenderManager.instance.itemRenderer instanceof ItemRenderer)) {
+			mod_LMM_LittleMaidMobX.Debug("replace RenderManager.itemRenderer.");
+			RenderManager.instance.itemRenderer = itemRenderer;
+		}
+		// GUIの表示を変えるには常時監視が必要？
+	}
+*/
+	public static void clientCustomPayload(Message var2) {
+		// クライアント側の特殊パケット受信動作
+		byte lmode = var2.data[0];
+		int leid = 0;
+		Entity lentity = null;
+		if ((lmode & 0x80) != 0) {
+			leid = Helper.getInt(var2.data, 1);
+			lentity = Helper.getEntity(var2.data, 1, Helper.mc.theWorld);
+			if (lentity == null) return;
+		}
+		LittleMaidMobX.Debug("MMM|Upd Clt Call[%2x:%d].", lmode, leid);
+		
+		switch (lmode) {
+		case NetConstants.Client_SetTextureIndex:
+			// 問い合わせたテクスチャパックの管理番号を受け取る
+			TextureManager.instance.reciveFormServerSetTexturePackIndex(var2.data);
+			break;
+		case NetConstants.Client_SetTexturePackName:
+			// 管理番号に登録されているテクスチャパックの情報を受け取る
+			TextureManager.instance.reciveFromServerSetTexturePackName(var2.data);
+			break;
+		}
+	}
+/*
+	public static void clientConnect(NetClientHandler var1) {
+		if (Helper.mc.isIntegratedServerRunning()) {
+			Debug("Localmode: InitTextureList.");
+			TextureManager.instance.initTextureList(true);
+		} else {
+			Debug("Remortmode: ClearTextureList.");
+			TextureManager.instance.initTextureList(false);
+		}
+	}
+
+	public static void clientDisconnect(NetClientHandler var1) {
+//		super.clientDisconnect(var1);
+//		Debug("Localmode: InitTextureList.");
+//		TextureManager.initTextureList(true);
+	}
+
+	public static void sendToServer(byte[] pData) {
+		ModLoader.clientSendPacket(new Packet250CustomPayload("MMM|Upd", pData));
+		Debug("MMM|Upd:%2x:NOEntity", pData[0]);
+	}
+*/
+	public static boolean isIntegratedServerRunning() {
+		return Minecraft.getMinecraft().isIntegratedServerRunning();
+	}
+
+	/**
+	 * Duoを使う時は必ずRender側のこの関数を置き換えること。
+	 * @param par1EntityLiving
+	 * @param par2
+	 */
+	public static void renderArrowsStuckInEntity(EntityLivingBase par1EntityLiving, float par2,
+			Render pRender, ModelBase pModel) {
+		int lacount = par1EntityLiving.getArrowCountInEntity();
+		
+		if (lacount > 0) {
+			EntityArrow larrow = new EntityArrow(par1EntityLiving.worldObj, par1EntityLiving.posX, par1EntityLiving.posY, par1EntityLiving.posZ);
+			Random lrand = new Random((long)par1EntityLiving.getEntityId());
+			RenderHelper.disableStandardItemLighting();
+			
+			for (int var6 = 0; var6 < lacount; ++var6) {
+				GL11.glPushMatrix();
+				GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
+				ModelRenderer var7 = pModel.getRandomModelBox(lrand);
+				ModelBoxBase var8 = var7.cubeList.get(lrand.nextInt(var7.cubeList.size()));
+				var7.postRender(0.0625F);
+				float var9 = lrand.nextFloat();
+				float var10 = lrand.nextFloat();
+				float var11 = lrand.nextFloat();
+				float var12 = (var8.posX1 + (var8.posX2 - var8.posX1) * var9) / 16.0F;
+				float var13 = (var8.posY1 + (var8.posY2 - var8.posY1) * var10) / 16.0F;
+				float var14 = (var8.posZ1 + (var8.posZ2 - var8.posZ1) * var11) / 16.0F;
+				GL11.glTranslatef(var12, var13, var14);
+				var9 = var9 * 2.0F - 1.0F;
+				var10 = var10 * 2.0F - 1.0F;
+				var11 = var11 * 2.0F - 1.0F;
+				var9 *= -1.0F;
+				var10 *= -1.0F;
+				var11 *= -1.0F;
+				float var15 = MathHelper.sqrt_float(var9 * var9 + var11 * var11);
+				larrow.prevRotationYaw = larrow.rotationYaw = (float)(Math.atan2((double)var9, (double)var11) * 180.0D / Math.PI);
+				larrow.prevRotationPitch = larrow.rotationPitch = (float)(Math.atan2((double)var10, (double)var15) * 180.0D / Math.PI);
+				double var16 = 0.0D;
+				double var18 = 0.0D;
+				double var20 = 0.0D;
+				float var22 = 0.0F;
+//				pRender.renderManager.renderEntityWithPosYaw(larrow, var16, var18, var20, var22, par2);
+				RenderManager.instance.renderEntityWithPosYaw(larrow, var16, var18, var20, var22, par2);
+				GL11.glPopMatrix();
+			}
+			
+			RenderHelper.enableStandardItemLighting();
+		}
+	}
+/*
+	public static World getMCtheWorld() {
+		if (Helper.mc !=  null) {
+			return Helper.mc.theWorld;
+		}
+		return null;
+	}
+*/
+	public static void setLightmapTextureCoords(int pValue) {
+//		int ls = pValue % 65536;
+//		int lt = pValue / 65536;
+		int ls = pValue & 0xffff;
+		int lt = pValue >>> 16;
+		OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit,
+				(float) ls / 1.0F, (float) lt / 1.0F);
+	}
+
+	public static void setTexture(ResourceLocation pRLocation) {
+		if (pRLocation != null) {
+			Minecraft.getMinecraft().renderEngine.bindTexture(pRLocation);
+		}
+	}
+/*
+	public static String getVersionString() {
+		return Minecraft.func_110431_a(Minecraft.getMinecraft());
+	}
+*/
+
+	public static World getMCtheWorld()
+	{
+		return Minecraft.getMinecraft().theWorld;
+	}
+
+	public static void sendToServer(byte[] ldata) {
+		Network.sendPacketToServer(1, ldata);
+	}
+}
diff --git a/src/main/java/littleMaidMobX/Counter.java b/src/main/java/littleMaidMobX/Counter.java
new file mode 100755
index 0000000..98d69b8
--- /dev/null
+++ b/src/main/java/littleMaidMobX/Counter.java
@@ -0,0 +1,71 @@
+package littleMaidMobX;
+
+
+/**
+ * カウンタ用。
+ */
+public class Counter {
+
+	protected int fSetValue;
+	protected int fMaxValue;
+	protected int fDelayValue;
+	protected int fCounter;
+
+
+	public Counter() {
+		this(25, 20, -10);
+	}
+
+	public Counter(int pSetValue, int pMaxValue, int pDelayValue) {
+		fSetValue = pSetValue;
+		fMaxValue = pMaxValue;
+		fDelayValue = pDelayValue;
+		fCounter = pDelayValue;
+	}
+
+
+	public void setCountValue(int pSetValue, int pMaxValue, int pDelayValue) {
+		fSetValue = pSetValue;
+		fMaxValue = pMaxValue;
+		fDelayValue = pDelayValue;
+	}
+
+	public void setValue(int pValue) {
+		fCounter = pValue;
+	}
+
+	public int getValue() {
+		return fCounter;
+	}
+
+	public void setEnable(boolean pFlag) {
+		fCounter = pFlag ? (isEnable() ? fMaxValue : fSetValue) : fDelayValue;
+	}
+
+	public boolean isEnable() {
+		return fCounter > 0;
+	}
+
+	public boolean isDelay() {
+		return fCounter > fDelayValue;
+	}
+
+	public boolean isReady() {
+		return fCounter >= fMaxValue;
+	}
+
+	public void onUpdate() {
+		if (fCounter > fDelayValue) {
+			fCounter--;
+		}
+	}
+
+	public void updateClient(boolean pFlag) {
+		if (pFlag) {
+			fCounter = fMaxValue;
+		} else if (fCounter > 0) {
+			fCounter = 0;
+		}
+	}
+
+}
diff --git a/src/main/java/littleMaidMobX/EventHook.java b/src/main/java/littleMaidMobX/EventHook.java
new file mode 100755
index 0000000..ebe9f5a
--- /dev/null
+++ b/src/main/java/littleMaidMobX/EventHook.java
@@ -0,0 +1,20 @@
+package littleMaidMobX;
+
+import littleMaidMobX.entity.EntityLittleMaidAvatar;
+import net.minecraftforge.event.entity.player.EntityItemPickupEvent;
+import cpw.mods.fml.common.eventhandler.SubscribeEvent;
+
+public class EventHook
+{
+	@SubscribeEvent
+	public void onEntityItemPickupEvent(EntityItemPickupEvent event)
+	{
+		if(event.entityPlayer instanceof EntityLittleMaidAvatar)
+		{
+			if(event.item!=null && LittleMaidMobX.isMaidIgnoreItem(event.item.getEntityItem()))
+			{
+				event.setCanceled(true);
+			}
+		}
+	}
+}
diff --git a/src/main/java/littleMaidMobX/Helper.java b/src/main/java/littleMaidMobX/Helper.java
new file mode 100755
index 0000000..717c106
--- /dev/null
+++ b/src/main/java/littleMaidMobX/Helper.java
@@ -0,0 +1,678 @@
+package littleMaidMobX;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import net.minecraft.client.Minecraft;
+import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityList;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.entity.SharedMonsterAttributes;
+import net.minecraft.entity.ai.attributes.AttributeModifier;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.init.Items;
+import net.minecraft.inventory.Container;
+import net.minecraft.inventory.Slot;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemPotion;
+import net.minecraft.item.ItemStack;
+import net.minecraft.item.crafting.FurnaceRecipes;
+import net.minecraft.pathfinding.PathNavigate;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.util.AxisAlignedBB;
+import net.minecraft.util.MathHelper;
+import net.minecraft.util.MovingObjectPosition;
+import net.minecraft.util.MovingObjectPosition.MovingObjectType;
+import net.minecraft.util.Vec3;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.BiomeGenBase;
+import net.minecraft.world.biome.BiomeGenBase.SpawnListEntry;
+import cpw.mods.fml.common.ObfuscationReflectionHelper;
+
+public class Helper {
+
+	public static final boolean isClient;
+	public static final Package fpackage = null;
+//	public static final String packegeBase;
+	public static final boolean isForge = true;//ModLoader.isModLoaded("Forge");
+	public static final Minecraft mc;
+//	public static Method methGetSmeltingResultForge = null;
+	public static Class entityRegistry = null;
+	public static Method registerModEntity = null;
+	protected static final Map<Class, Class>replaceEntitys = new HashMap<Class, Class>();
+	protected static Map<String, Integer> entityIDList = new HashMap<String, Integer>();
+	
+	static {
+		// TODO 必要ない？
+//		fpackage = ModLoader.class.getPackage();
+//		packegeBase = "";//fpackage == null ? "" : fpackage.getName().concat(".");
+
+		Minecraft lm = null;
+		try {
+			lm =  Minecraft.getMinecraft();// ModLoader.getMinecraftInstance();
+		} catch (Exception e) {
+//			e.printStackTrace();
+		} catch (Error e) {
+//			e.printStackTrace();
+		}
+		mc = lm;
+		isClient = mc != null;
+		/*
+		if (isForge) {
+			try {
+				methGetSmeltingResultForge = FurnaceRecipes.class.getMethod("getExperience", ItemStack.class);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+			try {
+				entityRegistry = getNameOfClass("cpw.mods.fml.common.registry.EntityRegistry");
+				registerModEntity = entityRegistry.getMethod("registerModEntity",
+						Class.class, String.class, int.class, Object.class, int.class, int.class, boolean.class);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+		*/
+	}
+
+	/**
+	 * 現在の実行環境がローカルかどうかを判定する。
+	 */
+	public static boolean isLocalPlay() {
+		return isClient && mc.isIntegratedServerRunning();
+	}
+
+	/**
+	 * マルチ対応用。
+	 * ItemStackに情報更新を行うと、サーバー側との差異からSlotのアップデートが行われる。
+	 * その際、UsingItemの更新処理が行われないため違うアイテムに持替えられたと判定される。
+	 * ここでは比較用に使われるスタックリストを強制的に書換える事により対応した。
+	 */
+	public static void updateCheckinghSlot(Entity pEntity, ItemStack pItemstack) {
+		if (pEntity instanceof EntityPlayerMP) {
+			// サーバー側でのみ処理
+			EntityPlayerMP lep = (EntityPlayerMP)pEntity;
+			Container lctr = lep.openContainer;
+			for (int li = 0; li < lctr.inventorySlots.size(); li++) {
+				ItemStack lis = ((Slot)lctr.getSlot(li)).getStack(); 
+				if (lis == pItemstack) {
+					lctr.inventoryItemStacks.set(li, pItemstack.copy());
+					break;
+				}
+			}
+		}
+	}
+	
+	public static String getPlayerName(EntityPlayer player)
+	{
+		return player.getGameProfile().getName();
+	}
+	
+	/**
+	 * Forge用クラス獲得。
+	 */
+	/*
+	使用箇所無し 削除
+	public static Class getForgeClass(BaseMod pMod, String pName) {
+		if (isForge) {
+			pName = pName.concat("_Forge");
+		}
+		return getNameOfClass(pName);
+	}
+	*/
+
+	/**
+	 * 名前からクラスを獲得する
+	 */
+	public static Class getNameOfClass(String pName) {
+		if (fpackage != null) {
+			pName = fpackage.getName() + "." + pName;
+		}
+		Class lclass = null;
+		try {
+			lclass = Class.forName(pName);
+		} catch (Exception e) {
+			LittleMaidMobX.Debug("Class:%s is not found.", pName);
+		}
+		
+		return lclass;
+	}
+
+	/**
+	 * 送信用データのセット
+	 */
+	public static void setValue(byte[] pData, int pIndex, int pVal, int pSize) {
+		for (int li = 0; li < pSize; li++) {
+			pData[pIndex++] = (byte)(pVal & 0xff);
+			pVal = pVal >>> 8;
+		}
+	}
+	
+	public static void setInt(byte[] pData, int pIndex, int pVal) {
+		pData[pIndex + 3]	= (byte)(pVal & 0xff);
+		pData[pIndex + 2]	= (byte)((pVal >>> 8) & 0xff);
+		pData[pIndex + 1]	= (byte)((pVal >>> 16) & 0xff);
+		pData[pIndex + 0]	= (byte)((pVal >>> 24) & 0xff);
+	}
+	
+	public static int getInt(byte[] pData, int pIndex) {
+		return (pData[pIndex + 3] & 0xff) | ((pData[pIndex + 2] & 0xff) << 8) | ((pData[pIndex + 1] & 0xff) << 16) | ((pData[pIndex + 0] & 0xff) << 24);
+	}
+
+	public static void setFloat(byte[] pData, int pIndex, float pVal) {
+		setInt(pData, pIndex, Float.floatToIntBits(pVal));
+	}
+
+	public static float getFloat(byte[] pData, int pIndex) {
+		return Float.intBitsToFloat(getInt(pData, pIndex));
+	}
+
+	public static void setShort(byte[] pData, int pIndex, int pVal) {
+		pData[pIndex++]	= (byte)(pVal & 0xff);
+		pData[pIndex]	= (byte)((pVal >>> 8) & 0xff);
+	}
+
+	public static short getShort(byte[] pData, int pIndex) {
+		return (short)((pData[pIndex] & 0xff) | ((pData[pIndex + 1] & 0xff) << 8));
+	}
+
+	public static String getStr(byte[] pData, int pIndex, int pLen) {
+		String ls = new String(pData, pIndex, pLen);
+		return ls;
+	}
+	public static String getStr(byte[] pData, int pIndex) {
+		return getStr(pData, pIndex, pData.length - pIndex);
+	}
+
+	public static void setStr(byte[] pData, int pIndex, String pVal) {
+		byte[] lb = pVal.getBytes();
+		for (int li = pIndex; li < pData.length; li++) {
+			pData[li] = lb[li - pIndex];
+		}
+	}
+
+	// 状況判断要関数群
+	public static boolean canBlockBeSeen(Entity pEntity, int x, int y, int z, boolean toTop, boolean do1, boolean do2) {
+		// ブロックの可視判定
+		Vec3 vec3d = Vec3.createVectorHelper(pEntity.posX, pEntity.posY + pEntity.getEyeHeight(), pEntity.posZ);
+		Vec3 vec3d1 = Vec3.createVectorHelper((double)x + 0.5D, (double)y + (toTop ? 0.9D : 0.5D), (double)z + 0.5D);
+		
+		MovingObjectPosition movingobjectposition = pEntity.worldObj.func_147447_a(vec3d, vec3d1, do1, do2, false);
+		if (movingobjectposition == null) {
+			return false;
+		}
+		if (movingobjectposition.typeOfHit == MovingObjectType.BLOCK) {
+			if (movingobjectposition.blockX == MathHelper.floor_double(vec3d1.xCoord) && 
+				movingobjectposition.blockY == MathHelper.floor_double(vec3d1.yCoord) &&
+				movingobjectposition.blockZ == MathHelper.floor_double(vec3d1.zCoord)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public static boolean setPathToTile(EntityLiving pEntity, TileEntity pTarget, boolean flag) {
+		// Tileまでのパスを作る
+		PathNavigate lpn = pEntity.getNavigator();
+		float lspeed = 1.0F;
+		// 向きに合わせて距離を調整
+		int i = (pTarget.yCoord == MathHelper.floor_double(pEntity.posY) && flag) ? 2 : 1;
+		switch (pEntity.worldObj.getBlockMetadata(pTarget.xCoord, pTarget.yCoord, pTarget.zCoord)) {
+		case 3:
+			return lpn.tryMoveToXYZ(pTarget.xCoord, pTarget.yCoord, pTarget.zCoord + i, lspeed);
+		case 2:
+			return lpn.tryMoveToXYZ(pTarget.xCoord, pTarget.yCoord, pTarget.zCoord - i, lspeed);
+		case 5:
+			return lpn.tryMoveToXYZ(pTarget.xCoord + 1, pTarget.yCoord, pTarget.zCoord, lspeed);
+		case 4:
+			return lpn.tryMoveToXYZ(pTarget.xCoord - i, pTarget.yCoord, pTarget.zCoord, lspeed);
+		default:
+			return lpn.tryMoveToXYZ(pTarget.xCoord, pTarget.yCoord, pTarget.zCoord, lspeed);
+		}
+	}
+
+	/**
+	 * Modloader環境下で空いているEntityIDを返す。
+	 * 有効な値を獲得できなければ-1を返す。
+	 */
+	/*
+	private static int getNextEntityID(boolean isLiving) {
+		if (isLiving) {
+			// 生物用
+			for (int li = 1; li < 256; li++) {
+				if (EntityList.getClassFromID(li) == null) {
+					return li;
+				}
+			}
+		} else {
+			// 物用
+			for (int li = MMMLib.cfg_startVehicleEntityID; li < MMMLib.cfg_startVehicleEntityID + 2048; li++) {
+				if (EntityList.getClassFromID(li) == null) {
+					return li;
+				}
+			}
+		}
+		return -1;
+	}
+	*/
+
+	/**
+	 * Entityを登録する。
+	 * RML、Forge両対応。
+	 * @param entityclass
+	 * @param entityName
+	 * @param defaultId
+	 * 0 : オートアサイン
+	 * @param mod
+	 * @param uniqueModeName
+	 * @param trackingRange
+	 * @param updateFrequency
+	 * @param sendVelocityUpdate
+	 */
+	/*
+	public static int registerEntity(
+			Class<? extends Entity> entityclass, String entityName, int defaultId,
+			BaseMod mod, int trackingRange, int updateFrequency, boolean sendVelocityUpdate,
+			int pEggColor1, int pEggColor2) {
+		int lid = 0;
+		lid = getModEntityID(mod.getName());
+		if (isForge) {
+			try {
+				Method lmethod;
+				// EntityIDの獲得
+				lmethod = entityRegistry.getMethod("findGlobalUniqueEntityId");
+				defaultId = (Integer)lmethod.invoke(null);
+				
+				if (pEggColor1 == 0 && pEggColor2 == 0) {
+					lmethod = entityRegistry.getMethod("registerGlobalEntityID",
+							Class.class, String.class, int.class);
+					lmethod.invoke(null, entityclass, entityName, defaultId);
+				} else {
+					lmethod = entityRegistry.getMethod("registerGlobalEntityID",
+							Class.class, String.class, int.class, int.class, int.class);
+					lmethod.invoke(null, entityclass, entityName, defaultId, pEggColor1, pEggColor2);
+				}
+				// EntityListへの登録は適当な数字でよい。
+				registerModEntity.invoke(
+						null, entityclass, entityName, lid,
+						mod, trackingRange, updateFrequency, sendVelocityUpdate);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		} else {
+			// EntityListへの登録は
+			if (defaultId == 0) {
+				defaultId = getNextEntityID(entityclass.isAssignableFrom(EntityLivingBase.class));
+			}
+			if (pEggColor1 == 0 && pEggColor2 == 0) {
+				ModLoader.registerEntityID(entityclass, entityName, defaultId);
+			} else {
+				ModLoader.registerEntityID(entityclass, entityName, defaultId, pEggColor1, pEggColor2);
+			}
+			ModLoader.addEntityTracker(mod, entityclass, defaultId, trackingRange, updateFrequency, sendVelocityUpdate);
+		}
+		LMM_LittleMaidMobX.Debug("RegisterEntity ID:%d / %s-%d : %s", defaultId, mod.getName(), lid, entityName);
+		return defaultId;
+	}
+	public static int registerEntity(
+			Class<? extends Entity> entityclass, String entityName, int defaultId,
+			BaseMod mod, int trackingRange, int updateFrequency, boolean sendVelocityUpdate) {
+		return registerEntity(entityclass, entityName, defaultId, mod, trackingRange, updateFrequency, sendVelocityUpdate, 0, 0);
+	}
+	*/
+
+	private static int getModEntityID(String uniqueModeName) {
+		int li = 0;
+		if (entityIDList.containsKey(uniqueModeName)) {
+			li = entityIDList.get(uniqueModeName);
+		}
+		entityIDList.put(uniqueModeName, li + 1);
+		return li;
+	}
+
+	/**
+	 * Entityを返す。
+	 */
+	public static Entity getEntity(byte[] pData, int pIndex, World pWorld) {
+		return pWorld.getEntityByID(Helper.getInt(pData, pIndex));
+	}
+
+	/**
+	 * 変数「avatar」から値を取り出し戻り値として返す。
+	 * avatarが存在しない場合は元の値を返す。
+	 * avatarはEntityLiving互換。
+	 */
+	public static Entity getAvatarEntity(Entity pEntity){
+		// littleMaid用コードここから
+		if (pEntity == null) return null;
+		try {
+			// 射手の情報をEntityLittleMaidAvatarからEntityLittleMaidへ置き換える
+			Field field = pEntity.getClass().getField("avatar");
+			pEntity = (EntityLivingBase)field.get(pEntity);
+		} catch (NoSuchFieldException e) {
+		} catch (Exception e) {
+			e.printStackTrace();
+		} catch (Error e) {
+			e.printStackTrace();
+		}
+		// ここまで
+		return pEntity;
+	}
+
+	/**
+	 * 変数「maidAvatar」から値を取り出し戻り値として返す。
+	 * maidAvatarが存在しない場合は元の値を返す。
+	 * maidAvatarはEntityPlayer互換。
+	 */
+	public static Entity getAvatarPlayer(Entity entity) {
+		// メイドさんチェック
+		try {
+			Field field = entity.getClass().getField("maidAvatar");
+			entity = (Entity)field.get(entity);
+		}
+		catch (NoSuchFieldException e) {
+		}
+		catch (Exception e) {
+		}
+		return entity;
+	}
+
+	/**
+	 * プレーヤのインベントリからアイテムを減らす
+	 */
+	public static ItemStack decPlayerInventory(EntityPlayer par1EntityPlayer, int par2Index, int par3DecCount) {
+		if (par1EntityPlayer == null) {
+			return null;
+		}
+		
+		if (par2Index == -1) {
+			par2Index = par1EntityPlayer.inventory.currentItem;
+		}
+		ItemStack itemstack1 = par1EntityPlayer.inventory.getStackInSlot(par2Index);
+		if (itemstack1 == null) {
+			return null;
+		}
+		
+		if (!par1EntityPlayer.capabilities.isCreativeMode) {
+			// クリエイティブだと減らない
+			itemstack1.stackSize -= par3DecCount;
+		}
+		
+		if (itemstack1.getItem() instanceof ItemPotion) {
+			if(itemstack1.stackSize <= 0) {
+				par1EntityPlayer.inventory.setInventorySlotContents(par1EntityPlayer.inventory.currentItem, new ItemStack(Items.glass_bottle, par3DecCount));
+				return null;
+			} else {
+				par1EntityPlayer.inventory.addItemStackToInventory(new ItemStack(Items.glass_bottle, par3DecCount));
+			}
+		} else {
+			if (itemstack1.stackSize <= 0) {
+				par1EntityPlayer.inventory.setInventorySlotContents(par2Index, null);
+				return null;
+			}
+		}
+		
+		return itemstack1;
+	}
+
+	protected static float convRevision(String pRev) {
+		Pattern lp = Pattern.compile("(\\d+)(\\w*)");
+		Matcher lm = lp.matcher(pRev);
+		float lf = 0;
+		if (lm.find()) {
+			lf = Integer.valueOf(lm.group(1));
+			if (!lm.group(2).isEmpty()) {
+				lf += (float)(lm.group(2).charAt(0) - 96) * 0.01;
+			}
+		}
+		return lf;
+	}
+	protected static float convRevision() {
+		// TODO ★後回し
+		return 0;// convRevision(MMMLib.Revision);
+	}
+
+	/**
+	 * 指定されたリビジョンよりも古ければ例外を投げてストップ
+	 */
+	public static void checkRevision(String pRev) {
+		if (convRevision() < convRevision(pRev)) {
+			// 適合バージョンではないのでストップ
+		// TODO ★後回し
+		//	ModLoader.getLogger().warning("you must check MMMLib revision.");
+		//	throw new RuntimeException("The revision of MMMLib is old.");
+		}
+	}
+
+	/**
+	 * EntityListに登録されていいるEntityを置き換える。
+	 */
+	public static void replaceEntityList(Class pSrcClass, Class pDestClass) {
+		// EntityList登録情報を置き換え
+		// 古いEntityでもスポーンできるように一部の物は二重登録
+		try {
+			// stringToClassMapping
+			Map lmap;
+			int lint = 0;
+			String ls = "";
+			lmap = EntityList.stringToClassMapping;
+			for (Entry<String, Class> le : ((Map<String, Class>)lmap).entrySet()) {
+				if (le.getValue() == pSrcClass) {
+					le.setValue(pDestClass);
+				}
+			}
+			// classToStringMapping
+			lmap = EntityList.classToStringMapping;
+			if (lmap.containsKey(pSrcClass)) {
+				ls = (String)lmap.get(pSrcClass);
+//				lmap.remove(pSrcClass);
+				lmap.put(pDestClass, ls);
+			}
+			// IDtoClassMapping
+			lmap = EntityList.IDtoClassMapping;
+			for (Entry<Integer, Class> le : ((Map<Integer, Class>)lmap).entrySet()) {
+				if (le.getValue() == pSrcClass) {
+					le.setValue(pDestClass);
+				}
+			}
+			// classToIDMapping なんぜコイツだけprivateのまま？
+			lmap = (Map)ObfuscationReflectionHelper.getPrivateValue(EntityList.class, null, "field_75624_e", "classToIDMapping");
+			if (lmap.containsKey(pSrcClass)) {
+				lint = (Integer)lmap.get(pSrcClass);
+//				lmap.remove(pSrcClass);
+				lmap.put(pDestClass, lint);
+			}
+			replaceEntitys.put(pSrcClass, pDestClass);
+			LittleMaidMobX.Debug("Replace %s -> %s(EntityListID: %d, EntityListString: %s)", pSrcClass.getSimpleName(), pDestClass.getSimpleName(), lint, ls);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	private static void replaceCreatureList(List<SpawnListEntry> pMobs) {
+		if (pMobs == null) return;
+		for (Entry<Class, Class> le : replaceEntitys.entrySet()) {
+			for (int j = 0; j < pMobs.size(); j++) {
+				if (pMobs.get(j).entityClass == le.getKey()) {
+					pMobs.get(j).entityClass = le.getValue();
+					LittleMaidMobX.Debug("ReplaceCreatureList: %s -> %s", le.getKey().getSimpleName(), le.getValue().getSimpleName());
+				}
+			}
+		}
+	}
+
+	/**
+	 * バイオームの設定Entityを置き換えられたEntityへ置き換える。
+	 * 基本的にMMMLib以外からは呼ばれない。
+	 */
+	protected static void replaceBaiomeSpawn() {
+		// バイオームの発生処理をのっとる
+		if (replaceEntitys.isEmpty()) return;
+		BiomeGenBase[] biomeList = BiomeGenBase.getBiomeGenArray();
+		for (int i = 0; i < biomeList.length; i++) {
+			if (biomeList[i] == null) continue;
+			List<SpawnListEntry> mobs;
+			LittleMaidMobX.Debug("ReplaceBaiomeSpawn:%s", biomeList[i].biomeName);
+			LittleMaidMobX.Debug("[Creature]");
+			replaceCreatureList(biomeList[i].getSpawnableList(EnumCreatureType.creature));//.spawnableCreatureList);
+			LittleMaidMobX.Debug("[WaterCreature]");
+			replaceCreatureList(biomeList[i].getSpawnableList(EnumCreatureType.waterCreature));//.spawnableWaterCreatureList);
+			LittleMaidMobX.Debug("[CaveCreature]");
+			replaceCreatureList(biomeList[i].getSpawnableList(EnumCreatureType.ambient));//.spawnableCaveCreatureList);
+			LittleMaidMobX.Debug("[Monster]");
+			replaceCreatureList(biomeList[i].getSpawnableList(EnumCreatureType.monster));//.spawnableMonsterList);
+		}
+	}
+
+	/**
+	 * 視線の先にいる最初のEntityを返す
+	 * @param pEntity
+	 * 視点
+	 * @param pRange
+	 * 視線の有効距離
+	 * @param pDelta
+	 * 時刻補正
+	 * @param pExpand
+	 * 検知領域の拡大範囲
+	 * @return
+	 */
+	public static Entity getRayTraceEntity(EntityLivingBase pEntity, double pRange, float pDelta, float pExpand) {
+		Vec3 lvpos = Vec3.createVectorHelper(
+				pEntity.posX, pEntity.posY + pEntity.getEyeHeight(), pEntity.posZ);
+//		Vec3 lvpos = pEntity.getPosition(pDelta).addVector(0D, pEntity.getEyeHeight(), 0D);
+		Vec3 lvlook = pEntity.getLook(pDelta);
+		Vec3 lvview = lvpos.addVector(lvlook.xCoord * pRange, lvlook.yCoord * pRange, lvlook.zCoord * pRange);
+		Entity ltarget = null;
+		List llist = pEntity.worldObj.getEntitiesWithinAABBExcludingEntity(pEntity, pEntity.boundingBox.addCoord(lvlook.xCoord * pRange, lvlook.yCoord * pRange, lvlook.zCoord * pRange).expand((double)pExpand, (double)pExpand, (double)pExpand));
+		double ltdistance = pRange * pRange;
+		
+		for (int var13 = 0; var13 < llist.size(); ++var13) {
+			Entity lentity = (Entity)llist.get(var13);
+			
+			if (lentity.canBeCollidedWith()) {
+				float lexpand = lentity.getCollisionBorderSize() + 0.3F;
+				AxisAlignedBB laabb = lentity.boundingBox.expand((double)lexpand, (double)lexpand, (double)lexpand);
+				MovingObjectPosition lmop = laabb.calculateIntercept(lvpos, lvview);
+				
+				if (laabb.isVecInside(lvpos)) {
+					if (0.0D < ltdistance || ltdistance == 0.0D) {
+						ltarget = lentity;
+						ltdistance = 0.0D;
+					}
+				} else if (lmop != null) {
+					double ldis = lvpos.squareDistanceTo(lmop.hitVec);
+					
+					if (ldis < ltdistance || ltdistance == 0.0D) {
+						ltarget = lentity;
+						ltdistance = ldis;
+					}
+				}
+			}
+		}
+		return ltarget;
+	}
+
+
+	// Forge対策
+
+	/**
+	 * Forge対策用のメソッド
+	 */
+	public static ItemStack getSmeltingResult(ItemStack pItemstack) {
+/*
+		if (methGetSmeltingResultForge != null) {
+			try {
+				return (ItemStack)methGetSmeltingResultForge.invoke(FurnaceRecipes.smelting(), pItemstack);
+			}catch (Exception e) {
+			}
+		}
+*/
+		return FurnaceRecipes.smelting().getSmeltingResult(pItemstack);
+	}
+
+	/**
+	 * アイテムに追加効果が在るかを判定する。
+	 * Forge対策。
+	 * @param pItemStack
+	 * @return
+	 */
+	public static boolean hasEffect(ItemStack pItemStack) {
+		// マジClientSIDEとか辞めてほしい。
+		if (pItemStack != null) {
+			Item litem = pItemStack.getItem();
+			if (litem instanceof ItemPotion) {
+				List llist = ((ItemPotion)litem).getEffects(pItemStack);
+				return llist != null && !llist.isEmpty();
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Blockのインスタンスを置き換える。
+	 * static finalの変数に対して行うのでForgeでは無効。
+	 * @param pOriginal
+	 * @param pReplace
+	 * @return
+	 */
+	/*
+	public static boolean replaceBlock(Block pOriginal, Block pReplace) {
+		if (isForge) {
+			return false;
+		}
+		try {
+			// Blockのstatic final分の置換え
+			Field[] lfield = Block.class.getDeclaredFields();
+			for (int li = 0; li < lfield.length; li++) {
+				if (!Modifier.isStatic(lfield[li].getModifiers())) {
+					// static以外は対象外
+					continue;
+				}
+				
+				Object lobject = lfield[li].get(null);
+				if (lobject == pOriginal) {
+					ModLoader.setPrivateValue(Block.class, null, li, pReplace);
+					return true;
+				}
+			}
+		}
+		catch(Exception exception) {
+		}
+		return false;
+	}
+	*/
+
+	/**
+	 * 16進数の文字列をIntへ変換する。
+	 * 0xffffffff対策。
+	 * @param pValue
+	 * @return
+	 */
+	public static int getHexToInt(String pValue) {
+		String ls = "00000000".concat(pValue);
+		int llen = ls.length();
+		int li = Integer.parseInt(ls.substring(llen - 4, llen), 16);
+		int lj = Integer.parseInt(ls.substring(llen - 8, llen - 4), 16);
+		return (lj << 16) | li;
+	}
+
+	/**
+	 *  アイテムに設定された攻撃力を見る
+	 * @param pItemStack
+	 * @return
+	 */
+	public static double getAttackVSEntity(ItemStack pItemStack) {
+		AttributeModifier lam = (AttributeModifier)pItemStack.getAttributeModifiers().get(SharedMonsterAttributes.attackDamage.getAttributeUnlocalizedName());
+		return lam == null ? 0 : lam.getAmount();
+	}
+
+}
diff --git a/src/main/java/littleMaidMobX/LMM_EntityCaps.java b/src/main/java/littleMaidMobX/LMM_EntityCaps.java
deleted file mode 100644
index 38d60ab..0000000
--- a/src/main/java/littleMaidMobX/LMM_EntityCaps.java
+++ /dev/null
@@ -1,195 +0,0 @@
-package littleMaidMobX;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import mmmlibx.lib.MMM_EntityCaps;
-import net.minecraft.item.EnumAction;
-import net.minecraft.item.ItemStack;
-
-
-/**
- * Entityのデータ読み取り用のクラス
- * 別にEntityにインターフェース付けてもOK
- */
-public class LMM_EntityCaps extends MMM_EntityCaps {
-
-	private LMM_EntityLittleMaid owner;
-	private static Map<String, Integer> caps;
-
-	static {
-		caps = new HashMap<String, Integer>();
-		caps.putAll(getStaticModelCaps());
-		caps.put("isBloodsuck", caps_isBloodsuck);
-		caps.put("isFreedom", caps_isFreedom);
-		caps.put("isTracer", caps_isTracer);
-		caps.put("isPlaying", caps_isPlaying);
-		caps.put("isLookSuger", caps_isLookSuger);
-		caps.put("isBlocking", caps_isBlocking);
-		caps.put("isWait", caps_isWait);
-		caps.put("isWaitEX", caps_isWaitEX);
-		caps.put("isOpenInv", caps_isOpenInv);
-		caps.put("isWorking", caps_isWorking);
-		caps.put("isWorkingDelay", caps_isWorkingDelay);
-		caps.put("isContract", caps_isContract);
-		caps.put("isContractEX", caps_isContractEX);
-		caps.put("isRemainsC", caps_isRemainsC);
-		caps.put("isClock", caps_isClock);
-		caps.put("isMasked", caps_isMasked);
-		caps.put("isCamouflage", caps_isCamouflage);
-		caps.put("isPlanter", caps_isPlanter);
-		caps.put("isOverdrive", caps_isOverdrive);
-		caps.put("isOverdriveDelay", caps_isOverdriveDelay);
-		caps.put("entityIdFactor", caps_entityIdFactor);
-		caps.put("height", caps_height);
-		caps.put("width", caps_width);
-		caps.put("YOffset", caps_YOffset);
-		caps.put("mountedYOffset", caps_mountedYOffset);
-		caps.put("dominantArm", caps_dominantArm);
-//		caps.put("render", caps_render);
-//		caps.put("Arms", caps_Arms);
-		caps.put("HeadMount", caps_HeadMount);
-//		caps.put("HardPoint", caps_HardPoint);
-		caps.put("Items", caps_Items);
-		caps.put("Actions", caps_Actions);
-		caps.put("Grounds", caps_Grounds);
-		caps.put("Ground", caps_Ground);
-		caps.put("Inventory", caps_Inventory);
-		caps.put("interestedAngle", caps_interestedAngle);
-//		caps.put("Entity", caps_Entity);
-//		caps.put("health", caps_health);
-		caps.put("currentArmor", caps_currentArmor);
-		caps.put("currentEquippedItem", caps_currentEquippedItem);
-	}
-
-	public LMM_EntityCaps(LMM_EntityLittleMaid pOwner) {
-		super(pOwner);
-		owner = pOwner;
-	}
-
-	@Override
-	public Map<String, Integer> getModelCaps() {
-		return caps;
-	}
-
-	@Override
-	public Object getCapsValue(int pIndex, Object ...pArg) {
-		int li = 0;
-		
-		switch (pIndex) {
-//		case caps_Entity:
-//			return owner;
-//		case caps_health:
-//			return (int)owner.getHealth();
-//		case caps_healthFloat:
-//			return owner.getHealth();
-		case caps_isBloodsuck:
-			return owner.isBloodsuck();
-		case caps_isFreedom:
-			return owner.isFreedom();
-		case caps_isTracer:
-			return owner.isTracer();
-		case caps_isPlaying:
-			return owner.isPlaying();
-		case caps_isLookSuger:
-			return owner.isLookSuger();
-		case caps_isBlocking:
-			return owner.isBlocking();
-		case caps_isWait:
-			return owner.isMaidWait();
-		case caps_isWaitEX:
-			return owner.isMaidWaitEx();
-		case caps_isOpenInv:
-			return owner.isOpenInventory();
-		case caps_isWorking:
-			return owner.isWorking();
-		case caps_isWorkingDelay:
-			return owner.isWorkingDelay();
-		case caps_isContract:
-			return owner.isContract();
-		case caps_isContractEX:
-			return owner.isContractEX();
-		case caps_isRemainsC:
-			return owner.isRemainsContract();
-		case caps_isClock:
-			return owner.isClockMaid();
-		case caps_isMasked:
-			return owner.isMaskedMaid();
-		case caps_isCamouflage:
-			return owner.isCamouflage();
-		case caps_isPlanter:
-			return owner.isPlanter();
-		case caps_isOverdrive:
-			return owner.maidOverDriveTime.isEnable();
-		case caps_isOverdriveDelay:
-			return owner.maidOverDriveTime.isDelay();
-		case caps_entityIdFactor:
-			return owner.entityIdFactor;
-		case caps_height:
-			return owner.textureData.textureBox[0] == null ? null : owner.textureData.textureBox[0].getHeight(this);
-		case caps_width:
-			return owner.textureData.textureBox[0] == null ? null : owner.textureData.textureBox[0].getWidth(this);
-		case caps_YOffset:
-			return owner.textureData.textureBox[0] == null ? null : owner.textureData.textureBox[0].getYOffset(this);
-		case caps_mountedYOffset:
-			return owner.textureData.textureBox[0] == null ? null : owner.textureData.textureBox[0].getMountedYOffset(this);
-		case caps_dominantArm:
-			return owner.maidDominantArm;
-//		case caps_mountedYOffset:
-//			return owner.textureModel0 == null ? null : owner.textureModel0.getHeight();
-//		case caps_render:
-//		case caps_Arms:
-		case caps_HeadMount:
-			return owner.maidInventory.getStackInSlot(17);
-//		case caps_HardPoint:
-		case caps_Items:
-			ItemStack[] lstacks = new ItemStack[owner.mstatSwingStatus.length];
-			for (LMM_SwingStatus ls : owner.mstatSwingStatus) {
-				lstacks[li++] = ls.getItemStack(owner);
-			}
-			return lstacks;
-		case caps_Actions:
-			EnumAction[] lactions = new EnumAction[owner.mstatSwingStatus.length];
-			for (LMM_SwingStatus ls : owner.mstatSwingStatus) {
-				lactions[li++] = ls.isUsingItem() ? ls.getItemStack(owner).getItemUseAction() : null;
-			}
-			return lactions;
-		case caps_Grounds:
-			float[] lgrounds = new float[owner.mstatSwingStatus.length];
-			for (LMM_SwingStatus ls : owner.mstatSwingStatus) {
-				lgrounds[li++] = ls.onGround;
-			}
-			return lgrounds;
-		case caps_Ground:
-			// float (int pIndex, int pDefVal)
-			if (owner.mstatSwingStatus.length < (Integer)pArg[0]) {
-				return pArg[1];
-			}
-			return owner.mstatSwingStatus[(Integer)pArg[0]].onGround;
-		case caps_Inventory:
-			return owner.maidInventory;
-		case caps_interestedAngle:
-			return owner.getInterestedAngle((Float)pArg[0]);
-//		case caps_currentArmor:
-//			return owner.getCurrentItemOrArmor((Integer)pArg[0] + 1);
-//		case caps_currentEquippedItem:
-//			return owner.getCurrentEquippedItem();
-		case caps_PartsVisible:
-			return owner.textureData.selectValue;
-		case caps_textureData:
-			return owner.textureData;
-		}
-		
-		return super.getCapsValue(pIndex, pArg);
-	}
-
-	@Override
-	public boolean setCapsValue(int pIndex, Object... pArg) {
-		switch (pIndex) {
-		case caps_PartsVisible:
-			owner.textureData.selectValue = (Integer)pArg[0];
-		}
-		return super.setCapsValue(pIndex, pArg);
-	}
-
-}
diff --git a/src/main/java/littleMaidMobX/LMM_EntityLittleMaid.java b/src/main/java/littleMaidMobX/LMM_EntityLittleMaid.java
deleted file mode 100644
index 6ae3fd9..0000000
--- a/src/main/java/littleMaidMobX/LMM_EntityLittleMaid.java
+++ /dev/null
@@ -1,3515 +0,0 @@
-package littleMaidMobX;
-
-import static littleMaidMobX.LMM_Statics.dataWatch_Absoption;
-import static littleMaidMobX.LMM_Statics.dataWatch_Color;
-import static littleMaidMobX.LMM_Statics.dataWatch_DominamtArm;
-import static littleMaidMobX.LMM_Statics.dataWatch_ExpValue;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_Aimebow;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_Bloodsuck;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_Freedom;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_LooksSugar;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_OverDrive;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_Tracer;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_Wait;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_Working;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_looksWithInterest;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_looksWithInterestAXIS;
-import static littleMaidMobX.LMM_Statics.dataWatch_Flags_remainsContract;
-import static littleMaidMobX.LMM_Statics.dataWatch_Free;
-import static littleMaidMobX.LMM_Statics.dataWatch_Gotcha;
-import static littleMaidMobX.LMM_Statics.dataWatch_ItemUse;
-import static littleMaidMobX.LMM_Statics.dataWatch_Mode;
-import static littleMaidMobX.LMM_Statics.dataWatch_Parts;
-import static littleMaidMobX.LMM_Statics.dataWatch_Texture;
-
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.UUID;
-
-import littleMaidMobX.ai.LMM_EntityAIAttackArrow;
-import littleMaidMobX.ai.LMM_EntityAIAttackOnCollide;
-import littleMaidMobX.ai.LMM_EntityAIAvoidPlayer;
-import littleMaidMobX.ai.LMM_EntityAIBeg;
-import littleMaidMobX.ai.LMM_EntityAIBegMove;
-import littleMaidMobX.ai.LMM_EntityAICollectItem;
-import littleMaidMobX.ai.LMM_EntityAIFindBlock;
-import littleMaidMobX.ai.LMM_EntityAIFleeRain;
-import littleMaidMobX.ai.LMM_EntityAIFollowOwner;
-import littleMaidMobX.ai.LMM_EntityAIJumpToMaster;
-import littleMaidMobX.ai.LMM_EntityAIRestrictRain;
-import littleMaidMobX.ai.LMM_EntityAISwimming;
-import littleMaidMobX.ai.LMM_EntityAITracerMove;
-import littleMaidMobX.ai.LMM_EntityAIWait;
-import littleMaidMobX.ai.LMM_EntityAIWander;
-import littleMaidMobX.ai.LMM_IEntityAI;
-import littleMaidMobX.inventory.InventoryLittleMaid;
-import littleMaidMobX.models.IModelCaps;
-import littleMaidMobX.modes.LMM_EntityModeBase;
-import littleMaidMobX.modes.LMM_EntityModeManager;
-import littleMaidMobX.modes.LMM_EntityMode_Playing;
-import littleMaidMobX.modes.LMM_IFF;
-import mmmlibx.lib.ITextureEntity;
-import mmmlibx.lib.MMM_Counter;
-import mmmlibx.lib.MMM_Helper;
-import mmmlibx.lib.MMM_TextureBox;
-import mmmlibx.lib.MMM_TextureBoxBase;
-import mmmlibx.lib.MMM_TextureBoxServer;
-import mmmlibx.lib.MMM_TextureData;
-import mmmlibx.lib.MMM_TextureManager;
-import net.minecraft.block.Block;
-import net.minecraft.block.BlockDoublePlant;
-import net.minecraft.block.BlockLeaves;
-import net.minecraft.block.BlockPumpkin;
-import net.minecraft.block.BlockStainedGlass;
-import net.minecraft.entity.Entity;
-import net.minecraft.entity.EntityAgeable;
-import net.minecraft.entity.EntityCreature;
-import net.minecraft.entity.EntityList;
-import net.minecraft.entity.EntityLivingBase;
-import net.minecraft.entity.IEntityLivingData;
-import net.minecraft.entity.SharedMonsterAttributes;
-import net.minecraft.entity.ai.EntityAILeapAtTarget;
-import net.minecraft.entity.ai.EntityAILookIdle;
-import net.minecraft.entity.ai.EntityAIOpenDoor;
-import net.minecraft.entity.ai.EntityAIPanic;
-import net.minecraft.entity.ai.EntityAIRestrictOpenDoor;
-import net.minecraft.entity.ai.EntityAISwimming;
-import net.minecraft.entity.ai.EntityAITasks;
-import net.minecraft.entity.ai.EntityAITasks.EntityAITaskEntry;
-import net.minecraft.entity.ai.EntityAITempt;
-import net.minecraft.entity.ai.EntityAIWatchClosest;
-import net.minecraft.entity.ai.attributes.AttributeModifier;
-import net.minecraft.entity.ai.attributes.IAttributeInstance;
-import net.minecraft.entity.item.EntityItem;
-import net.minecraft.entity.monster.EntityMob;
-import net.minecraft.entity.passive.EntityChicken;
-import net.minecraft.entity.passive.EntityHorse;
-import net.minecraft.entity.passive.EntitySquid;
-import net.minecraft.entity.passive.EntityTameable;
-import net.minecraft.entity.player.EntityPlayer;
-import net.minecraft.entity.player.EntityPlayerMP;
-import net.minecraft.entity.projectile.EntityArrow;
-import net.minecraft.init.Items;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemArmor;
-import net.minecraft.item.ItemAxe;
-import net.minecraft.item.ItemBlock;
-import net.minecraft.item.ItemPotion;
-import net.minecraft.item.ItemSkull;
-import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagList;
-import net.minecraft.network.play.server.S04PacketEntityEquipment;
-import net.minecraft.network.play.server.S1DPacketEntityEffect;
-import net.minecraft.network.play.server.S1EPacketRemoveEntityEffect;
-import net.minecraft.pathfinding.PathEntity;
-import net.minecraft.potion.Potion;
-import net.minecraft.potion.PotionEffect;
-import net.minecraft.profiler.Profiler;
-import net.minecraft.tileentity.TileEntity;
-import net.minecraft.util.ChatComponentText;
-import net.minecraft.util.DamageSource;
-import net.minecraft.util.IIcon;
-import net.minecraft.util.MathHelper;
-import net.minecraft.util.ResourceLocation;
-import net.minecraft.util.Vec3;
-import net.minecraft.world.EnumDifficulty;
-import net.minecraft.world.World;
-import net.minecraft.world.WorldServer;
-import net.minecraft.world.biome.BiomeGenBase;
-import wrapper.W_Common;
-import cpw.mods.fml.common.ObfuscationReflectionHelper;
- 
-public class LMM_EntityLittleMaid extends EntityTameable implements ITextureEntity {
-
-	// 定数はStaticsへ移動
-//	protected static final UUID maidUUID = UUID.nameUUIDFromBytes("lmm.littleMaidMob".getBytes());
-	protected static final UUID maidUUID = UUID.fromString("e2361272-644a-3028-8416-8536667f0efb");
-//	protected static final UUID maidUUIDSneak = UUID.nameUUIDFromBytes("lmm.littleMaidMob.sneak".getBytes());
-	protected static final UUID maidUUIDSneak = UUID.fromString("5649cf91-29bb-3a0c-8c31-b170a1045560");
-	protected static AttributeModifier attCombatSpeed = (new AttributeModifier(maidUUID, "Combat speed boost", 0.07D, 0)).setSaved(false);
-	protected static AttributeModifier attAxeAmp = (new AttributeModifier(maidUUID, "Axe Attack boost", 0.5D, 1)).setSaved(false);
-	protected static AttributeModifier attSneakingSpeed = (new AttributeModifier(maidUUIDSneak, "Sneking speed ampd", -0.4D, 2)).setSaved(false);
-
-
-	// 変数減らしたいなぁ
-//	protected long maidContractLimit;		// 契約失効日
-	public int maidContractLimit;		// 契約期間
-	protected long maidAnniversary;			// 契約日UIDとして使用
-	public int maidDominantArm;			// 利き腕、1Byte
-	/** テクスチャ関連のデータを管理 **/
-	public MMM_TextureData textureData;
-	
-	
-	public InventoryLittleMaid maidInventory;
-	public LMM_EntityLittleMaidAvatar maidAvatar;
-	public LMM_EntityCaps maidCaps;	// Client側のみ
-	
-	public List<LMM_EntityModeBase> maidEntityModeList;
-	public Map<Integer, EntityAITasks[]> maidModeList;
-	public Map<String, Integer> maidModeIndexList;
-	public int maidMode;		// 2Byte
-	public boolean maidTracer;
-	public boolean maidFreedom;
-	public boolean maidWait;
-	public int homeWorld;
-	public int maidTiles[][] = new int[9][3];
-	public int maidTile[] = new int[3];
-	public TileEntity maidTileEntity;
-	
-	// 動的な状態
-	public EntityPlayer mstatMasterEntity;	// 主
-	public double mstatMasterDistanceSq;		// 主との距離、計算軽量化用
-	protected Entity mstatgotcha;				// ワイヤード用
-	protected boolean mstatBloodsuck;
-	protected boolean mstatClockMaid;
-	// マスク判定
-	protected int mstatMaskSelect;
-	// 追加の頭部装備
-	protected boolean mstatCamouflage;
-	protected boolean mstatPlanter;
-//	protected boolean isMaidChaseWait;
-	protected int mstatWaitCount;
-	protected int mstatTime;
-	public MMM_Counter maidOverDriveTime;
-	protected boolean mstatFirstLook;
-	protected boolean mstatLookSuger;
-	protected MMM_Counter mstatWorkingCount;
-	protected int mstatPlayingRole;
-	protected int mstatWorkingInt;
-	protected String mstatModeName;
-	protected boolean mstatOpenInventory;
-	// 腕振り
-	public LMM_SwingStatus mstatSwingStatus[]; 
-	public boolean mstatAimeBow;
-	// 首周り
-	private boolean looksWithInterest;
-	private boolean looksWithInterestAXIS;
-	private float rotateAngleHead;			// Angle
-	private float prevRotateAngleHead;		// prevAngle
-
-	/**
-	 * 個体ごとに値をバラつかせるのに使う。
-	 */
-	public float entityIdFactor;
-	
-	public boolean weaponFullAuto;	// 装備がフルオート武器かどうか
-	public boolean weaponReload;	// 装備がリロードを欲しているかどうか
-	public boolean maidCamouflage;
-	
-	
-	// 音声
-//	protected LMM_EnumSound maidAttackSound;
-	public LMM_EnumSound maidDamegeSound;
-	protected int maidSoundInterval;
-	
-	//TODO: figure out if its required to set this value
-	// minecraft has volume faders for different categories already
-	// the categories are defined in our sounds.json
-	protected float maidSoundRate = 0.8F;
-	
-	// 実験用
-	private int firstload = 1;
-	public String statusMessage = "";
-	
-	
-	// AI
-	public EntityAITempt aiTempt;
-	public LMM_EntityAIBeg aiBeg;
-	public LMM_EntityAIBegMove aiBegMove;
-	public EntityAIOpenDoor aiOpenDoor;
-	public EntityAIRestrictOpenDoor aiCloseDoor;
-	public LMM_EntityAIAvoidPlayer aiAvoidPlayer;
-	public LMM_EntityAIFollowOwner aiFollow;
-	public LMM_EntityAIAttackOnCollide aiAttack;
-	public LMM_EntityAIAttackArrow aiShooting;
-	public LMM_EntityAICollectItem aiCollectItem;
-	public LMM_EntityAIRestrictRain aiRestrictRain;
-	public LMM_EntityAIFleeRain aiFreeRain;
-	public LMM_EntityAIWander aiWander;
-	public LMM_EntityAIJumpToMaster aiJumpTo;
-	public LMM_EntityAIFindBlock aiFindBlock;
-	public LMM_EntityAITracerMove aiTracer;
-	public EntityAISwimming aiSwiming;
-	public EntityAIPanic aiPanic;
-	// ActiveModeClass
-	public LMM_EntityModeBase maidActiveModeClass;
-	public Profiler aiProfiler;
-
-
-	public LMM_EntityLittleMaid(World par1World) {
-		super(par1World);
-		// 初期設定
-		maidInventory = new InventoryLittleMaid(this);
-		if (par1World != null ) {
-			maidAvatar = new LMM_EntityLittleMaidAvatar(par1World, this);
-		}
-		mstatOpenInventory = false;
-//		isMaidChaseWait = false;
-		mstatTime = 6000;
-		maidOverDriveTime = new MMM_Counter(5, 300, -100);
-		mstatWorkingCount = new MMM_Counter(11, 10, -10);
-		
-		// モデルレンダリング用のフラグ獲得用ヘルパー関数
-		maidCaps = new LMM_EntityCaps(this);
-		
-		// 形態形成場
-		textureData = new MMM_TextureData(this, maidCaps);
-		textureData.setColor(12);
-		MMM_TextureBox ltb[] = new MMM_TextureBox[2];
-		ltb[0] = ltb[1] = MMM_TextureManager.instance.getDefaultTexture(this);
-		setTexturePackName(ltb);
-		
-		entityIdFactor = (float)(getEntityId() * 70);
-		// 腕振り
-		mstatSwingStatus = new LMM_SwingStatus[] { new LMM_SwingStatus(), new LMM_SwingStatus()};
-		setDominantArm(rand.nextInt(mstatSwingStatus.length));
-		
-		// 再生音声
-//		maidAttackSound = LMM_EnumSound.attack;
-		maidDamegeSound = LMM_EnumSound.hurt;
-		maidSoundInterval = 0;
-		
-		// 野生種用初期値設定
-		setHealth(15F);
-		
-		// 移動用フィジカル設定
-		getNavigator().setAvoidsWater(true);
-		getNavigator().setBreakDoors(true);
-		
-		
-		// TODO:これはテスト
-//		maidStabilizer.put("HeadTop", MMM_StabilizerManager.getStabilizer("WitchHat", "HeadTop"));
-		
-		
-		
-		// EntityModeの追加
-		maidEntityModeList = LMM_EntityModeManager.instance.createMaidModes(this);
-		// モードリスト
-		maidActiveModeClass = null;
-		maidModeList = new HashMap<Integer, EntityAITasks[]>();
-		maidModeIndexList = new HashMap<String, Integer>();
-		initModeList();
-		mstatModeName = "";
-		maidMode = 65535;
-		// 初期化時実行コード
-		for (LMM_EntityModeBase lem : maidEntityModeList) {
-			lem.initEntity();
-		}
-	}
-
-	@Override
-	public IEntityLivingData onSpawnWithEgg(IEntityLivingData par1EntityLivingData) {
-		// テクスチャーをランダムで選択
-		String ls;
-		if (LMM_LittleMaidMobX.cfg_defaultTexture.isEmpty()) {
-			ls = MMM_TextureManager.instance.getRandomTextureString(rand);
-		} else {
-			ls = LMM_LittleMaidMobX.cfg_defaultTexture;
-		}
-		textureData.setTextureInitServer(ls);
-		LMM_LittleMaidMobX.Debug("init-ID:%d, %s:%d", getEntityId(), textureData.textureBox[0].textureName, textureData.getColor());
-		setTexturePackIndex(textureData.getColor(), textureData.textureIndex);
-		setMaidMode("Wild");
-		return super.onSpawnWithEgg(par1EntityLivingData);
-	}
-
-	protected void applyEntityAttributes() {
-		// 初期パラメーター
-		super.applyEntityAttributes();
-		// 対象移動可能範囲
-		getEntityAttribute(SharedMonsterAttributes.followRange).setBaseValue(20.0D);
-		// 基本移動速度
-		getEntityAttribute(SharedMonsterAttributes.movementSpeed).setBaseValue(0.23000000417232513D);
-		// 標準攻撃力１
-		getAttributeMap().registerAttribute(SharedMonsterAttributes.attackDamage).setBaseValue(1.0D);
-	}
-
-	@Override
-	protected void entityInit() {
-		super.entityInit();
-		/*
-		 * DataWatcherはクライアントからサーバーへは値を渡さない、渡せない。
-		 */
-		
-		// 使用中リスト
-		// 0:Flags
-		// 1:Air
-		// 2, 3, 4, 5,
-		// 6: HP
-		// 7, 8:PotionMap
-		// 9: ArrowCount
-		// 10: 固有名称
-		// 11: 名付判定
-		// 12: GrowingAge
-		// 16: Tame(4), Sit(1) 
-		// 17: ownerName
-		
-		// maidAvater用EntityPlayer互換変数
-		// 17 -> 18
-		// 18 : Absoption効果をクライアント側へ転送するのに使う
-		dataWatcher.addObject(dataWatch_Absoption, Float.valueOf(0.0F));
-		
-		// 独自分
-		// 19:maidColor
-		dataWatcher.addObject(dataWatch_Color, Byte.valueOf((byte)0));
-		// 20:選択テクスチャインデックス
-		dataWatcher.addObject(dataWatch_Texture, Integer.valueOf(0));
-		// 21:モデルパーツの表示フラグ
-		dataWatcher.addObject(dataWatch_Parts, Integer.valueOf(0));
-		// 22:状態遷移フラグ群(32Bit)、詳細はStatics参照
-		dataWatcher.addObject(dataWatch_Flags, Integer.valueOf(0));
-		// 23:GotchaID
-		dataWatcher.addObject(dataWatch_Gotcha, Integer.valueOf(0));
-		// 24:メイドモード
-		dataWatcher.addObject(dataWatch_Mode, Short.valueOf((short)0));
-		// 25:利き腕
-		dataWatcher.addObject(dataWatch_DominamtArm, Byte.valueOf((byte)0));
-		// 26:アイテムの使用判定
-		dataWatcher.addObject(dataWatch_ItemUse, Integer.valueOf(0));
-		// 27:保持経験値
-		dataWatcher.addObject(dataWatch_ExpValue, Integer.valueOf(0));
-		
-		// TODO:test
-		// 31:自由変数、EntityMode等で使用可能な変数。
-		dataWatcher.addObject(dataWatch_Free, new Integer(0));
-	}
-
-	public void initModeList() {
-		// AI
-		aiBeg = new LMM_EntityAIBeg(this, 8F);
-		aiBegMove = new LMM_EntityAIBegMove(this, 1.0F);
-		aiOpenDoor = new EntityAIOpenDoor(this, true);
-		aiCloseDoor = new EntityAIRestrictOpenDoor(this);
-		aiAvoidPlayer = new LMM_EntityAIAvoidPlayer(this, 1.0F, 3);
-		aiFollow = new LMM_EntityAIFollowOwner(this, 1.0F, 36D, 25D, 81D);
-		aiAttack = new LMM_EntityAIAttackOnCollide(this, 1.0F, true);
-		aiShooting = new LMM_EntityAIAttackArrow(this);
-		aiCollectItem = new LMM_EntityAICollectItem(this, 1.0F);
-		aiRestrictRain = new LMM_EntityAIRestrictRain(this);
-		aiFreeRain = new LMM_EntityAIFleeRain(this, 1.0F);
-		aiWander = new LMM_EntityAIWander(this, 1.0F);
-		aiJumpTo = new LMM_EntityAIJumpToMaster(this);
-		aiFindBlock = new LMM_EntityAIFindBlock(this);
-		aiSwiming = new LMM_EntityAISwimming(this);
-		aiPanic = new EntityAIPanic(this, 2.0F);
-		aiTracer = new LMM_EntityAITracerMove(this);
-		aiSit = new LMM_EntityAIWait(this);
-		
-		// TODO:これいらなくね？
-		aiProfiler = worldObj != null && worldObj.theProfiler != null ? worldObj.theProfiler : null;
-
-		// 動作モード用のTasksListを初期化
-		EntityAITasks ltasks[] = new EntityAITasks[2];
-		ltasks[0] = new EntityAITasks(aiProfiler);
-		ltasks[1] = new EntityAITasks(aiProfiler);
-		
-		// default
-		ltasks[0].addTask(1, aiSwiming);
-		ltasks[0].addTask(2, aiSit);
-		ltasks[0].addTask(3, aiJumpTo);
-		ltasks[0].addTask(4, aiFindBlock);
-		ltasks[0].addTask(6, aiAttack);
-		ltasks[0].addTask(7, aiShooting);
-//		ltasks[0].addTask(8, aiPanic);
-		ltasks[0].addTask(10, aiBeg);
-		ltasks[0].addTask(11, aiBegMove);
-		ltasks[0].addTask(20, aiAvoidPlayer);
-		ltasks[0].addTask(21, aiFreeRain);
-		ltasks[0].addTask(22, aiCollectItem);
-		// 移動用AI
-		ltasks[0].addTask(30, aiTracer);
-		ltasks[0].addTask(31, aiFollow);
-		ltasks[0].addTask(32, aiWander);
-		ltasks[0].addTask(33, new EntityAILeapAtTarget(this, 0.3F));
-		// Mutexの影響しない特殊行動
-		ltasks[0].addTask(40, aiCloseDoor);
-		ltasks[0].addTask(41, aiOpenDoor);
-		ltasks[0].addTask(42, aiRestrictRain);
-		// 首の動き単独
-		ltasks[0].addTask(51, new EntityAIWatchClosest(this, EntityLivingBase.class, 10F));
-		ltasks[0].addTask(52, new EntityAILookIdle(this));
-		
-		// 追加分
-		for (LMM_EntityModeBase ieml : maidEntityModeList) {
-			ieml.addEntityMode(ltasks[0], ltasks[1]);
-		}
-	}
-
-
-	public void addMaidMode(EntityAITasks[] peaiTasks, String pmodeName, int pmodeIndex) {
-		maidModeList.put(pmodeIndex, peaiTasks);
-		maidModeIndexList.put(pmodeName, pmodeIndex);
-	}
-
-
-	public int getMaidModeInt() {
-		return maidMode;
-	}
-
-	public String getMaidModeString() {
-		if (!isContract()) {
-			return getMaidModeString(maidMode);
-		} else if (!isRemainsContract()) {
-			return "Strike";
-		} else if (isMaidWait()) {
-			return "Wait";
-		} else if (isPlaying()) {
-			return "Playing";
-		} else {
-			String ls = getMaidModeString(maidMode);
-			if (maidOverDriveTime.isEnable()) {
-				ls = "D-" + ls;
-			} else
-			if (isTracer()) {
-				ls = "T-" + ls;
-			} else
-			if (isFreedom()) {
-				ls = "F-" + ls;
-			}
-			return ls;
-		}
-	}
-
-	public String getMaidModeString(int pindex) {
-		// モード名称の獲得
-		String ls = "";
-		for (Entry<String, Integer> le : maidModeIndexList.entrySet()) {
-			if (le.getValue() == pindex) {
-				ls = le.getKey();
-				break;
-			}
-		}
-		return ls;
-	}
-
-	public boolean setMaidMode(String pname) {
-		return setMaidMode(pname, false);
-	}
-
-	public boolean setMaidMode(String pname, boolean pplaying) {
-		if (!maidModeIndexList.containsKey(pname)) {
-			return false;
-		}
-		return setMaidMode(maidModeIndexList.get(pname), pplaying);
-	}
-
-	public boolean setMaidMode(int pindex) {
-		return setMaidMode(pindex, false);
-	}
-
-
-	public boolean setMaidMode(int pindex, boolean pplaying) {
-		// モードに応じてAIを切り替える
-		velocityChanged = true;
-		if (!maidModeList.containsKey(pindex)) return false;
-		if (maidMode == pindex) return true;
-		
-		if (pplaying) {
-			
-		} else {
-			mstatWorkingInt = pindex;
-		}
-		mstatModeName = getMaidModeString(pindex);
-		maidMode = pindex;
-		dataWatcher.updateObject(dataWatch_Mode, (short)maidMode);
-		EntityAITasks[] ltasks = maidModeList.get(pindex);
-		
-		// AIを根底から書き換える
-		if (ltasks.length > 0 && ltasks[0] != null) {
-			setMaidModeAITasks(ltasks[0], tasks);
-		} else {
-			setMaidModeAITasks(null, tasks);
-		}
-		if (ltasks.length > 1 && ltasks[1] != null) {
-			setMaidModeAITasks(ltasks[1], targetTasks);
-		} else {
-			setMaidModeAITasks(null, targetTasks);
-		}
-
-		// モード切替に応じた処理系を確保
-		maidAvatar.stopUsingItem();
-		setSitting(false);
-		setSneaking(false);
-		setActiveModeClass(null);
-		aiJumpTo.setEnable(true);
-//		aiFollow.setEnable(true);
-		aiAttack.setEnable(true);
-		aiShooting.setEnable(false);
-		aiAvoidPlayer.setEnable(true);
-//		aiWander.setEnable(maidFreedom);
-		setBloodsuck(false);
-		clearTilePosAll();
-		for (int li = 0; li < maidEntityModeList.size(); li++) {
-			LMM_EntityModeBase iem = maidEntityModeList.get(li); 
-			if (iem.setMode(maidMode)) {
-				setActiveModeClass(iem);
-				aiFollow.minDist = iem.getRangeToMaster(0);
-				aiFollow.maxDist = iem.getRangeToMaster(1);
-				break;
-			}
-		}
-		getNextEquipItem();
-		
-		return true;
-	}
-
-	protected void setMaidModeAITasks(EntityAITasks pTasksSRC, EntityAITasks pTasksDEST) {
-		// 既存のAIを削除して置き換える。
-		// 動作をクリア
-		try {
-			ArrayList<EntityAITaskEntry> ltasksDoDEST = getEntityAITasks_taskEntries(pTasksDEST);
-			ArrayList<EntityAITaskEntry> ltasksExeDEST = getEntityAITasks_executingTaskEntries(pTasksDEST);
-			
-			if (pTasksSRC == null) {
-				ltasksDoDEST.clear();
-				ltasksExeDEST.clear();
-			} else {
-				ArrayList<EntityAITaskEntry> ltasksDoSRC = getEntityAITasks_taskEntries(pTasksSRC);
-				ArrayList<EntityAITaskEntry> ltasksExeSRC = getEntityAITasks_executingTaskEntries(pTasksSRC);
-				
-				Iterator iterator;
-				iterator = ltasksExeDEST.iterator();
-				while (iterator.hasNext()) {
-					EntityAITaskEntry ltaskentory = (EntityAITaskEntry)iterator.next();
-					ltaskentory.action.resetTask();
-				}	
-				ltasksExeDEST.clear();
-				
-				ltasksDoDEST.clear();
-				ltasksDoDEST.addAll(ltasksDoSRC);
-				// TODO: 未実装の機能、モードチェンジ時の初期化を行う。
-				for (EntityAITaskEntry ltask : ltasksDoSRC) {
-					if (ltask instanceof LMM_IEntityAI)
-					{
-//						((LMM_IEntityAI)ltask).setDefaultEnable();
-					}
-				}
-			}
-		} catch (Exception s) {
-		}
-	}
-	public static ArrayList<EntityAITaskEntry> getEntityAITasks_taskEntries(EntityAITasks task)
-	{
-		return (ArrayList<EntityAITaskEntry>)ObfuscationReflectionHelper.getPrivateValue(EntityAITasks.class, task, "field_75782_a", "taskEntries");
-	}
-	public static ArrayList<EntityAITaskEntry> getEntityAITasks_executingTaskEntries(EntityAITasks task)
-	{
-		return (ArrayList<EntityAITaskEntry>)ObfuscationReflectionHelper.getPrivateValue(EntityAITasks.class, task, "field_75780_b", "executingTaskEntries");
-	}
-
-	/**
-	 * 適用されているモードクラス
-	 */
-	public LMM_EntityModeBase getActiveModeClass() {
-		return maidActiveModeClass;
-	}
-
-	public void setActiveModeClass(LMM_EntityModeBase pEntityMode) {
-		maidActiveModeClass = pEntityMode;
-	}
-
-	public boolean isActiveModeClass() {
-		return maidActiveModeClass != null;
-	}
-
-	// 効果音の設定
-	@Override
-	protected String getHurtSound() {
-		playSound(maidDamegeSound, true);
-		return null;
-	}
-
-	@Override
-	protected String getDeathSound() {
-		playSound(LMM_EnumSound.death, true);
-		return null;
-	}
-
-	@Override
-	protected String getLivingSound() {
-		// 普段の声
-		LMM_EnumSound so = LMM_EnumSound.Null;
-		if (getHealth() < 10)
-			so = LMM_EnumSound.living_whine;
-		else if (rand.nextFloat() < maidSoundRate) {
-			if (mstatTime > 23500 || mstatTime < 1500) {
-				so = LMM_EnumSound.living_morning;
-			} else if (mstatTime < 12500) {
-				if (isContract()) {
-					BiomeGenBase biomegenbase = worldObj.getBiomeGenForCoords(MathHelper.floor_double(posX + 0.5D), MathHelper.floor_double(posZ + 0.5D));
-					float ltemp = biomegenbase.getFloatTemperature((int)this.posX, (int)this.posY, (int)this.posZ);
-					if (ltemp <= 0.15F) {
-						so = LMM_EnumSound.living_cold;
-					} else if (ltemp > 1.0F) {
-						so = LMM_EnumSound.living_hot;
-					} else {
-						so = LMM_EnumSound.living_daytime;
-					}
-					if (worldObj.isRaining()) {
-						if (biomegenbase.canSpawnLightningBolt()) {
-							so = LMM_EnumSound.living_rain;
-						} else if (biomegenbase.getEnableSnow()) {
-							so = LMM_EnumSound.living_snow;
-						}
-					}
-				} else {
-					so = LMM_EnumSound.living_daytime;
-				}
-			} else {
-				so = LMM_EnumSound.living_night;
-			}
-		}
-		
-		LMM_LittleMaidMobX.Debug("id:%d LivingSound:%s", getEntityId(), worldObj == null ? "null" : worldObj.isRemote ? "Client" : "Server");
-		playLittleMaidSound(so, false);
-		return null;
-	}
-
-	/**
-	 * 簡易音声再生、標準の音声のみ使用すること。
-	 */
-	public void playSound(String pname) {
-		playSound(pname, 0.5F, (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F);
-	}
-
-	/**
-	 * ネットワーク対応音声再生
-	 */
-	public void playSound(LMM_EnumSound enumsound, boolean force) {
-		if ((maidSoundInterval > 0 && !force) || enumsound == LMM_EnumSound.Null) return;
-		maidSoundInterval = 20;
-		if (worldObj.isRemote) {
-			// Client
-//			String lsound = LMM_SoundManager.getSoundValue(enumsound, textureName, maidColor & 0x00ff);
-//			float lpitch = mod_LMM_littleMaidMob.VoiceDistortion ? (rand.nextFloat() * 0.2F) + 0.95F : 1.0F;
-//			worldObj.playSound(posX, posY, posZ, lsound, getSoundVolume(), lpitch, false);
-		} else {
-			// Server
-			LMM_LittleMaidMobX.Debug("id:%d-%s, seps:%04x-%s", getEntityId(), worldObj.isRemote ? "Client" : "Server",  enumsound.index, enumsound.name());
-			byte[] lbuf = new byte[] {
-					LMM_Statics.LMN_Client_PlaySound,
-					0, 0, 0, 0,
-					0, 0, 0, 0
-			};
-			MMM_Helper.setInt(lbuf, 5, enumsound.index);
-			LMM_Net.sendToAllEClient(this, lbuf);
-		}
-	}
-
-	/**
-	 * 音声再生用。
-	 * 通常の再生ではネットワーク越しになるのでその対策。
-	 */
-	public void playLittleMaidSound(LMM_EnumSound enumsound, boolean force) {
-		// 音声の再生
-		if ((maidSoundInterval > 0 && !force) || enumsound == LMM_EnumSound.Null) return;
-		maidSoundInterval = 20;
-		if (worldObj.isRemote) {
-			// Client
-			// TODO: TEST
-			String s = enumsound.toString();//LMM_SoundManager.getSoundValue(enumsound, textureData.getTextureName(0), textureData.getColor());
-			if(!s.isEmpty() && !s.startsWith("minecraft:"))
-			{
-				s = LMM_LittleMaidMobX.DOMAIN + ":" + s;
-			}
-			LMM_LittleMaidMobX.Debug(String.format("id:%d, se:%04x-%s (%s)", getEntityId(), enumsound.index, enumsound.name(), s));
-			if(!s.isEmpty())
-			{
-				float lpitch = LMM_LittleMaidMobX.cfg_VoiceDistortion ? (rand.nextFloat() * 0.2F) + 0.95F : 1.0F;
-				worldObj.playSound(posX, posY, posZ, s, getSoundVolume(), lpitch, false);
-			}
-		}
-	}
-
-	@Override
-	public void onKillEntity(EntityLivingBase par1EntityLiving) {
-		super.onKillEntity(par1EntityLiving);
-		if (isBloodsuck()) {
-//			mod_LMM_littleMaidMob.Debug("nice Kill.");
-			playSound(LMM_EnumSound.laughter, true);
-		} else {
-			setTarget(null);
-			setAttackTarget(null);
-		}
-	}
-
-	@Override
-	protected boolean canDespawn() {
-		// デスポーン判定
-		return LMM_LittleMaidMobX.cfg_canDespawn || super.canDespawn();
-	}
-
-	@Override
-	public boolean getCanSpawnHere() {
-		// スポーン可能か？
-		if (LMM_LittleMaidMobX.cfg_spawnLimit <= getMaidCount()) {
-			LMM_LittleMaidMobX.Debug("Spawn Limit.");
-			return false;
-		}
-		int lx = MathHelper.floor_double(this.posX);
-		int ly = MathHelper.floor_double(this.boundingBox.minY);
-		int lz = MathHelper.floor_double(this.posZ);
-		/*
-		// TODO:サーバー側で判定できないので意味なし?
-		MMM_TextureBox lbox = MMM_TextureManager.instance.getTextureBox(textureBox[0]);
-		if (worldObj == null || textureModel == null  
-				|| !textureBox[0].mo.getCanSpawnHere(worldObj, lx, ly, lz, this)) {
-			mod_LMM_littleMaidMob.Debug(String.format("%s is can't spawn hear.", textureName));
-			return false;
-		}
-		*/
-		if (LMM_LittleMaidMobX.cfg_Dominant) {
-			// ドミナント
-			return this.worldObj.checkNoEntityCollision(this.boundingBox) 
-					&& this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox).isEmpty() 
-					&& !this.worldObj.isAnyLiquid(this.boundingBox)
-					&& this.getBlockPathWeight(lx, ly, lz) >= 0.0F;
-		} else {
-			return super.getCanSpawnHere();
-		}
-	}
-
-	@Override
-	public void setDead() {
-		if (mstatgotcha != null) {
-			// 首紐をドロップ
-			EntityItem entityitem = new EntityItem(worldObj, mstatgotcha.posX, mstatgotcha.posY, mstatgotcha.posZ, new ItemStack(Items.string));
-			worldObj.spawnEntityInWorld(entityitem);
-			mstatgotcha = null;
-		}
-		super.setDead();
-	}
-
-	/**
-	 * 読み込み領域内のメイドさんの数
-	 */
-	public int getMaidCount() {
-		int lj = 0;
-		for (int li = 0; li < worldObj.loadedEntityList.size(); li++) {
-			if (worldObj.loadedEntityList.get(li) instanceof LMM_EntityLittleMaid) {
-				lj++;
-			}
-		}
-		return lj;
-	}
-
-	@Override
-	public EntityAgeable createChild(EntityAgeable var1) {
-		// お子さんの設定
-		return null;
-	}
-
-	// エフェクト表示
-	protected void showParticleFX(String s) {
-		showParticleFX(s, 1D, 1D, 1D);
-	}
-
-	protected void showParticleFX(String s, double d, double d1, double d2) {
-		showParticleFX(s, d, d1, d2, 0D, 0D, 0D);
-	}
-
-	protected void showParticleFX(String s, double d, double d1, double d2, double d3, double d4, double d5 ) {
-		for (int i = 0; i < 7; i++) {
-			double d6 = rand.nextGaussian() * d + d3;
-			double d7 = rand.nextGaussian() * d1 + d4;
-			double d8 = rand.nextGaussian() * d2 + d5;
-			worldObj.spawnParticle(s, (posX + (double)(rand.nextFloat() * width * 2.0F)) - (double)width, posY + 0.5D + (double)(rand.nextFloat() * height), (posZ + (double)(rand.nextFloat() * width * 2.0F)) - (double)width, d6, d7, d8);
-		}
-	}
-
-	@Override
-	public void handleHealthUpdate(byte par1) {
-		// worldObj.setEntityState(this, (byte))で指定されたアクションを実行
-		switch (par1) {
-		case 10:
-			// 不機嫌
-			showParticleFX("smoke", 0.02D, 0.02D, 0.02D);
-			break;
-		case 11:
-			// ゴキゲン
-			double a = getContractLimitDays() / 7D;
-			double d6 = a * 0.3D;
-			double d7 = a;
-			double d8 = a * 0.3D;
-			worldObj.spawnParticle("note", posX, posY + height + 0.1D, posZ, d6, d7, d8);
-			break;
-		case 12:
-			// 自由行動
-			showParticleFX("reddust", 0.5D, 0.5D, 0.5D, 1.0D, 1.0D, 1.0D);
-			break;
-		case 13:
-			// 不自由行動
-			showParticleFX("smoke", 0.02D, 0.02D, 0.02D);
-			break;
-		case 14:
-			// トレーサー
-			showParticleFX("explode", 0.3D, 0.3D, 0.3D, 0.0D, 0.0D, 0.0D);
-			break;
-			
-		default:
-			super.handleHealthUpdate(par1);
-		}
-	}
-
-	// ポーション効果のエフェクト
-	public void setAbsorptionAmount(float par1) {
-		// AbsorptionAmount
-		if (par1 < 0.0F) {
-			par1 = 0.0F;
-		}
-		
-		this.getDataWatcher().updateObject(dataWatch_Absoption, Float.valueOf(par1));
-	}
-	public float getAbsorptionAmount() {
-		return this.getDataWatcher().getWatchableObjectFloat(dataWatch_Absoption);
-	}
-
-
-	public int colorMultiplier(float pLight, float pPartialTicks) {
-		// 発光処理用
-		int lbase = 0;
-		if (maidOverDriveTime.isDelay()) {
-			int i;
-			if (maidOverDriveTime.isEnable()) {
-				i = 100;
-			} else {
-				i = 100 + maidOverDriveTime.getValue();
-			}
-			lbase = i << 24 | 0x00df0f0f;
-		}
-		
-		if (isActiveModeClass()) {
-			lbase = lbase | getActiveModeClass().colorMultiplier(pLight, pPartialTicks);
-		}
-		
-		return lbase;
-	}
-
-
-	// AI関連
-	@Override
-	protected boolean isAIEnabled() {
-		// 新AI対応
-		return true;
-	}
-	
-	/**
-	 * 敵味方識別
-	 */
-	public boolean getIFF(Entity pEntity) {
-		// 敵味方識別(敵=false)
-		if (pEntity == null || pEntity == mstatMasterEntity) {
-			return true;
-		}
-		
-		int tt = LMM_IFF.getIFF(getMaidMaster(), pEntity);
-		switch (tt) {
-		case LMM_IFF.iff_Enemy:
-			return false;
-		case LMM_IFF.iff_Friendry:
-			return true;
-		case LMM_IFF.iff_Unknown:
-			if (isBloodsuck()) {
-				// 血に餓えている時は敵
-				return false;
-			}
-			if (pEntity instanceof LMM_EntityLittleMaid) {
-				// お遊びモードのメイドには敵対しない
-				if (((LMM_EntityLittleMaid)pEntity).mstatPlayingRole > LMM_EntityMode_Playing.mpr_NULL) {
-					return true;
-				}
-			}
-			if (pEntity instanceof EntityCreature) {
-				// 相手が何をターゲットにしているかで決まる
-				Entity et = ((EntityCreature)pEntity).getEntityToAttack();
-				if (et != null && et == mstatMasterEntity) {
-					return false;
-				}
-				if (et == this) {
-					return false;
-				}
-				if (et instanceof LMM_EntityLittleMaid) {
-					// 同じマスターのメイドを攻撃対象としている
-					if (((LMM_EntityLittleMaid)et).getMaidMasterEntity() == mstatMasterEntity) {
-						return false;
-					}
-				}
-			}
-			return true;
-			
-		default :
-			return false;
-		}
-	}
-
-	@Override
-	public boolean canAttackClass(Class par1Class) {
-		// IFFの設定、クラス毎の判定しかできないので使わない。
-		return true;
-	}
-
-	@Override
-	public boolean attackEntityAsMob(Entity par1Entity) {
-
-		// 正常時は回復優先処理
-		if (getHealth() < 10 && !isBloodsuck() && maidInventory.hasItem(Items.sugar)) {
-			return true;
-		}
-		
-		// 特殊な攻撃処理
-		if (isActiveModeClass() && getActiveModeClass().attackEntityAsMob(maidMode, par1Entity)) {
-			return true;
-		}
-		
-		// 標準処理
-		setSwing(20, isBloodsuck() ? LMM_EnumSound.attack_bloodsuck : LMM_EnumSound.attack);
-		maidAvatar.attackTargetEntityWithCurrentItem(par1Entity);
-		return true;
-	}
-
-	@Override
-	public boolean isBreedingItem(ItemStack par1ItemStack) {
-		// お好みは何？
-		if (isContractEX()) {
-			return par1ItemStack.getItem() == Items.sugar;
-		} else {
-			return par1ItemStack.getItem() == Items.cake;
-		}
-	}
-
-	
-	@Override
-	public void writeEntityToNBT(NBTTagCompound par1nbtTagCompound) {
-		// データセーブ
-		super.writeEntityToNBT(par1nbtTagCompound);
-		
-		par1nbtTagCompound.setTag("Inventory", maidInventory.writeToNBT(new NBTTagList()));
-		par1nbtTagCompound.setString("Mode", getMaidModeString(mstatWorkingInt));
-		par1nbtTagCompound.setBoolean("Wait", isMaidWait());
-		par1nbtTagCompound.setBoolean("Freedom", isFreedom());
-		par1nbtTagCompound.setBoolean("Tracer", isTracer());
-		par1nbtTagCompound.setInteger("LimitCount", maidContractLimit);
-		par1nbtTagCompound.setLong("Anniversary", maidAnniversary);
-		par1nbtTagCompound.setInteger("EXP", experienceValue);
-		par1nbtTagCompound.setInteger("DominantArm", maidDominantArm);
-		par1nbtTagCompound.setInteger("Color", textureData.getColor());
-		par1nbtTagCompound.setString("texName", textureData.getTextureName(0));
-		par1nbtTagCompound.setString("texArmor", textureData.getTextureName(1));
-		// HomePosition
-		par1nbtTagCompound.setInteger("homeX", getHomePosition().posX);
-		par1nbtTagCompound.setInteger("homeY", getHomePosition().posY);
-		par1nbtTagCompound.setInteger("homeZ", getHomePosition().posZ);
-		par1nbtTagCompound.setInteger("homeWorld", homeWorld);
-		// Tiles
-		NBTTagCompound lnbt = new NBTTagCompound();
-		par1nbtTagCompound.setTag("Tiles", lnbt);
-		for (int li = 0; li < maidTiles.length; li++) {
-			if (maidTiles[li] != null) {
-				lnbt.setIntArray(String.valueOf(li), maidTiles[li]);
-			}
-		}
-		// 追加分
-		for (int li = 0; li < maidEntityModeList.size(); li++) {
-			maidEntityModeList.get(li).writeEntityToNBT(par1nbtTagCompound);
-		}
-	}
-
-	@Override
-	public void readEntityFromNBT(NBTTagCompound par1nbtTagCompound) {
-		// データロード
-		super.readEntityFromNBT(par1nbtTagCompound);
-		
-		if (par1nbtTagCompound.hasKey("ModeColor")) {
-			// 旧版からの継承
-			String s = par1nbtTagCompound.getString("Master");
-			if(s.length() > 0) {
-				W_Common.setOwner(this, s);
-				setContract(true);
-			}
-			NBTTagList nbttaglist = par1nbtTagCompound.getTagList("Inventory", 10);
-			maidInventory.readFromNBT(nbttaglist);
-			// アーマースロット変更に対応するためのコード
-			ItemStack[] armi = new ItemStack[4];
-			for (int i = 0; i < 4; i++) {
-				ItemStack is = maidInventory.armorItemInSlot(i);
-				if (is != null) {
-					armi[3 - ((ItemArmor)is.getItem()).armorType] = is; 
-				}
-			}
-			maidInventory.armorInventory = armi; 
-			//
-			setMaidWait(par1nbtTagCompound.getBoolean("Wait"));
-			setFreedom(par1nbtTagCompound.getBoolean("Freedom"));
-			setTracer(par1nbtTagCompound.getBoolean("Tracer"));
-			textureData.textureIndex[0] = MMM_TextureManager.instance.getIndexTextureBoxServer(this, par1nbtTagCompound.getString("texName"));
-			textureData.textureIndex[1] = MMM_TextureManager.instance.getIndexTextureBoxServer(this, par1nbtTagCompound.getString("texArmor"));
-			textureData.textureBox[0] = MMM_TextureManager.instance.getTextureBoxServer(textureData.textureIndex[0]);
-			textureData.textureBox[1] = MMM_TextureManager.instance.getTextureBoxServer(textureData.textureIndex[1]);
-			byte b = par1nbtTagCompound.getByte("ModeColor");
-			setColor(b & 0x0f);
-			switch ((b & 0xf0) >> 4) {
-			case 0:
-				setMaidMode(0x0000);	// Wild
-				break;
-			case 2:
-				setMaidMode(0x0001);	// Escorter
-				break;
-			case 4:
-				setMaidMode(0x0080);	// Fencer
-				break;
-			case 5:
-				setMaidMode(0x0000);	// Healer
-				break;
-			case 6:
-				setMaidMode(0x0021);	// Cooking
-				break;
-			case 7:
-				setMaidMode(0x00c0);	// Bloodsucker
-				break;
-			case 8:
-				setMaidMode(0x0083);	// Archer
-				break;
-			case 9:
-				setMaidMode(0x00c3);	// Blazingstar
-				break;
-			case 10:
-				setMaidMode(0x0081);	// Ripper
-				break;
-			case 11:
-				setMaidMode(0x00c2);	// Detonator
-				break;
-			case 12:
-				setMaidMode(0x00c1);	// TNT-D
-				break;
-			case 13:
-				setMaidMode(0x0020);	// Torcher
-				break;
-			case 15:
-				setMaidMode(0x0000);	// Pharmacist
-				break;
-			default :
-				setMaidMode(0x0000);	// Wild
-			}
-//			setMaidMode((b & 0xf0) >> 4);
-			int lhx = MathHelper.floor_double(posX);
-			int lhy = MathHelper.floor_double(posY);
-			int lhz = MathHelper.floor_double(posZ);;
-//			func_110172_bL().set(lhx, lhy, lhz);
-			getHomePosition().set(lhx, lhy, lhz);
-			long lcl = par1nbtTagCompound.getLong("Limit");
-			if (isContract() && lcl == 0) {
-				maidContractLimit = 24000;
-			} else {
-				maidContractLimit = (int)((lcl - worldObj.getTotalWorldTime()));
-			}
-			maidAnniversary = par1nbtTagCompound.getLong("Anniversary");
-			if (maidAnniversary == 0L && isContract()) {
-				// ダミーの数値を入れる
-				maidAnniversary = worldObj.getWorldTime() - getEntityId();
-			}
-			
-		} else {
-			// 新型
-			LMM_LittleMaidMobX.Debug("read." + worldObj.isRemote);
-			
-			maidInventory.readFromNBT(par1nbtTagCompound.getTagList("Inventory", 10));
-			setMaidWait(par1nbtTagCompound.getBoolean("Wait"));
-			setFreedom(par1nbtTagCompound.getBoolean("Freedom"));
-			setTracer(par1nbtTagCompound.getBoolean("Tracer"));
-			setMaidMode(par1nbtTagCompound.getString("Mode"));
-			if (par1nbtTagCompound.hasKey("LimitCount")) {
-				maidContractLimit = par1nbtTagCompound.getInteger("LimitCount");
-			} else {
-				long lcl = par1nbtTagCompound.getLong("Limit");
-				if (isContract() && lcl == 0) {
-					maidContractLimit = 24000;
-				} else {
-					maidContractLimit = (int)((lcl - worldObj.getWorldTime()));
-				}
-			}
-			if (isContract() && maidContractLimit == 0) {
-				// 値がおかしい時は１日分
-//				maidContractLimit = worldObj.getWorldTime() + 24000L;
-				maidContractLimit = 24000;
-			}
-			maidAnniversary = par1nbtTagCompound.getLong("Anniversary");
-			if (maidAnniversary == 0L && isContract()) {
-				// ダミーの数値を入れる
-				maidAnniversary = worldObj.getWorldTime() - getEntityId();
-			}
-			if (maidAvatar != null) {
-				maidAvatar.experienceTotal = par1nbtTagCompound.getInteger("EXP");
-			}
-			setDominantArm(par1nbtTagCompound.getInteger("DominantArm"));
-			if (mstatSwingStatus.length <= maidDominantArm) {
-				maidDominantArm = 0;
-			}
-			textureData.textureIndex[0] = MMM_TextureManager.instance.getIndexTextureBoxServer(this, par1nbtTagCompound.getString("texName"));
-			textureData.textureIndex[1] = MMM_TextureManager.instance.getIndexTextureBoxServer(this, par1nbtTagCompound.getString("texArmor"));
-			textureData.textureBox[0] = MMM_TextureManager.instance.getTextureBoxServer(textureData.textureIndex[0]);
-			textureData.textureBox[1] = MMM_TextureManager.instance.getTextureBoxServer(textureData.textureIndex[1]);
-			textureData.setColor(par1nbtTagCompound.getInteger("Color"));
-			setTexturePackIndex(textureData.color, textureData.getTextureIndex());
-			
-			// HomePosition
-			int lhx = par1nbtTagCompound.getInteger("homeX");
-			int lhy = par1nbtTagCompound.getInteger("homeY");
-			int lhz = par1nbtTagCompound.getInteger("homeZ");
-//			func_110172_bL().set(lhx, lhy, lhz);
-			getHomePosition().set(lhx, lhy, lhz);
-			homeWorld = par1nbtTagCompound.getInteger("homeWorld");
-			
-			// Tiles
-			NBTTagCompound lnbt = par1nbtTagCompound.getCompoundTag("Tiles");
-			for (int li = 0; li < maidTiles.length; li++) {
-				int ltile[] = lnbt.getIntArray(String.valueOf(li));
-				maidTiles[li] = ltile.length > 0 ? ltile : null;
-			}
-			
-			// 追加分
-			for (int li = 0; li < maidEntityModeList.size(); li++) {
-				maidEntityModeList.get(li).readEntityFromNBT(par1nbtTagCompound);
-			}
-		}
-		onInventoryChanged();
-		
-		// ドッペル対策
-		if (LMM_LittleMaidMobX.cfg_antiDoppelganger && maidAnniversary > 0L) {
-			for (int i = 0; i < worldObj.loadedEntityList.size(); i++) {
-				Entity entity1 = (Entity)worldObj.loadedEntityList.get(i);
-				if (!entity1.isDead && entity1 instanceof LMM_EntityLittleMaid) {
-					LMM_EntityLittleMaid elm = (LMM_EntityLittleMaid)entity1;
-					if (elm != this && elm.isContract() && elm.maidAnniversary == maidAnniversary
-							&& elm.getMaidMaster().equalsIgnoreCase(getMaidMaster())) {
-						// 新しい方を残す
-						if (getEntityId() > elm.getEntityId()) {
-							LMM_LittleMaidMobX.Debug(String.format("Load Doppelganger ID:%d, %d" ,elm.getEntityId(), maidAnniversary));
-							elm.setDead();
-						} else {
-							LMM_LittleMaidMobX.Debug(String.format("Load Doppelganger ID:%d, %d" ,getEntityId(), maidAnniversary));
-							setDead();
-							break;
-						}
-					}
-				}
-			}
-		} else {
-			LMM_LittleMaidMobX.Debug(String.format("Load ID:%d, MaidMaster:%s, x:%.1f, y:%.1f, z:%.1f, %d" ,getEntityId(), getMaidMaster(), posX, posY, posZ, maidAnniversary));
-		}
-		
-	}
-
-	@Override
-	public IIcon getItemIcon(ItemStack par1ItemStack, int par2) {
-		// アイテムの表示
-		if (maidAvatar != null) {
-			return maidAvatar.getItemIcon(par1ItemStack, par2);
-		}
-		
-		if (par1ItemStack.getItem().requiresMultipleRenderPasses()) {
-			return par1ItemStack.getItem().getIconFromDamageForRenderPass(par1ItemStack.getItemDamage(), par2);
-		} else {
-			return super.getItemIcon(par1ItemStack, par2);
-		}
-	}
-
-	public boolean canBePushed()
-	{
-		// --------------------------------------------
-		// 肩車状態でプレイヤーが馬に乗っているときは、当たり判定をなくす。
-		if (ridingEntity != null && ridingEntity == mstatMasterEntity) {
-			if(ridingEntity.ridingEntity instanceof EntityHorse)
-			{
-				return false;
-			}
-		}
-		// --------------------------------------------
-
-		return !this.isDead;
-	}
-
-	// おんぶおばけは無敵
-	@Override
-	public boolean canBeCollidedWith() {
-		if (ridingEntity != null && ridingEntity == mstatMasterEntity) {
-			ItemStack litemstack = ((EntityPlayer)mstatMasterEntity).getCurrentEquippedItem();
-			return (litemstack == null) || (litemstack.getItem() == Items.saddle);
-		} else {
-			return super.canBeCollidedWith();
-		}
-	}
-
-	@Override
-	public boolean canAttackWithItem() {
-		if (ridingEntity != null && ridingEntity == mstatMasterEntity) {
-			return false;
-		} else {
-			return super.canAttackWithItem();
-		}
-	}
-
-	@Override
-	public double getMountedYOffset() {
-		// TODO:ここは要調整
-		if (riddenByEntity instanceof EntityChicken) {
-			return height + 0.03D;
-		}
-		if (riddenByEntity instanceof EntitySquid) {
-			return height - 0.2D;
-		}
-		return super.getMountedYOffset() + 0.35D;
-	}
-
-	@Override
-	public double getYOffset() {
-		if(ridingEntity instanceof EntityPlayer) {
-			// 姿勢制御
-//			setSneaking(true);
-//			mstatAimeBow = true;
-//			updateAimebow();
-//			return (double)(yOffset - 1.8F);
-
-			// --------------------------------------------
-			// プレイヤーが馬に乗っているときは、肩車ではなく馬の後ろに乗る
-			if(ridingEntity.ridingEntity instanceof EntityHorse)
-			{
-				if(this.worldObj.isRemote)
-				{
-					return (double)(yOffset - 2.8F);
-				}
-				else
-				{
-					return (double)(yOffset - 1.0F);
-				}
-			}
-			// プレイヤーに肩車
-			else
-			{
-				return (double)(yOffset - 2.0F);
-			}
-			// --------------------------------------------
-		}
-		return (double)(yOffset - 0.25F);
-	}
-
-	@Override
-	public void updateRidden() {
-		// TODO:アップデート時にチェック
-		++ticksExisted;
-		//
-		
-		if(ridingEntity instanceof EntityPlayer) {
-			EntityPlayer lep = (EntityPlayer)ridingEntity;
-			
-			// ヘッドハガー
-			renderYawOffset = lep.renderYawOffset;
-			prevRenderYawOffset = lep.prevRenderYawOffset;
-			double llpx = lastTickPosX;
-			double llpy = lastTickPosY;
-			double llpz = lastTickPosZ;
-			
-			// ★注意：水に触れると ridingEntity はnullになる ★
-			super.updateRidden();
-			
-			renderYawOffset = lep.renderYawOffset;
-			if (((rotationYaw - renderYawOffset) % 360F) > 90F) {
-				rotationYaw = renderYawOffset + 90F;
-			}
-			if (((rotationYaw - renderYawOffset) % 360F) < -90F) {
-				rotationYaw = renderYawOffset - 90F;
-			}
-			if (((rotationYawHead - renderYawOffset) % 360F) > 90F) {
-				rotationYawHead = renderYawOffset + 90F;
-			}
-			if (((rotationYawHead - renderYawOffset) % 360F) < -90F) {
-				rotationYawHead = renderYawOffset - 90F;
-			}
-
-			double dx, dz;
-			// --------------------------------------------
-			// プレイヤーが馬に乗っているときは、肩車ではなく馬の後ろに乗る
-			// ridingEntity はsuper.updateRidden();によってNULLになる事があるので注意
-			if(lep.ridingEntity instanceof EntityHorse)
-			{
-				EntityHorse horse = (EntityHorse)lep.ridingEntity;
-				if(this.worldObj.isRemote)
-				{
-					dx = Math.sin(((double)horse.renderYawOffset * Math.PI) / 180D) * 0.5;
-					dz = Math.cos(((double)horse.renderYawOffset * Math.PI) / 180D) * 0.5;
-				}
-				else
-				{
-					dx = Math.sin(((double)horse.renderYawOffset * Math.PI) / 180D) * 0.9;
-					dz = Math.cos(((double)horse.renderYawOffset * Math.PI) / 180D) * 0.9;
-				}
-			}
-			else
-			{
-				dx = Math.sin(((double)lep.renderYawOffset * Math.PI) / 180D) * 0.35;
-				dz = Math.cos(((double)lep.renderYawOffset * Math.PI) / 180D) * 0.35;
-			}
-			// --------------------------------------------
-			
-			setPosition(lep.posX + dx, posY, lep.posZ - dz);
-			lastTickPosX = llpx;
-			lastTickPosY = llpy;
-			lastTickPosZ = llpz;
-		} else {
-			super.updateRidden();
-		}
-	}
-	
-	@Override
-	public void updateRiderPosition() {
-		super.updateRiderPosition();
-	}
-
-	@Override
-	public float getSwingProgress(float par1) {
-		for (LMM_SwingStatus lswing : mstatSwingStatus) {
-			lswing.getSwingProgress(par1);
-		}
-		return getSwingStatusDominant().onGround;
-	}
-
-	// 首周り
-	public void setLooksWithInterest(boolean f) {
-		if (looksWithInterest != f) {
-			looksWithInterest = f;
-			if (numTicksToChaseTarget <= 0) {
-				looksWithInterestAXIS = rand.nextBoolean();
-			}
-			int li = dataWatcher.getWatchableObjectInt(dataWatch_Flags);
-			li = looksWithInterest ? (li | dataWatch_Flags_looksWithInterest) : (li & ~dataWatch_Flags_looksWithInterest);
-			li = looksWithInterestAXIS ? (li | dataWatch_Flags_looksWithInterestAXIS) : (li & ~dataWatch_Flags_looksWithInterestAXIS);
-			dataWatcher.updateObject(dataWatch_Flags, Integer.valueOf(li));
-		}
-	}
-
-	public boolean getLooksWithInterest() {
-		looksWithInterest = (dataWatcher.getWatchableObjectInt(dataWatch_Flags) & dataWatch_Flags_looksWithInterest) > 0;
-		looksWithInterestAXIS = (dataWatcher.getWatchableObjectInt(dataWatch_Flags) & dataWatch_Flags_looksWithInterestAXIS) > 0;
-
-		return looksWithInterest;
-	}
-
-	public float getInterestedAngle(float f) {
-		return (prevRotateAngleHead + (rotateAngleHead - prevRotateAngleHead) * f) * ((looksWithInterestAXIS ? 0.08F : -0.08F) * (float)Math.PI);
-	}
-
-
-	// ダメージコントロール
-//	@Override
-	public boolean isBlocking() {
-		return getSwingStatusDominant().isBlocking();
-//		return maidAvatar.isBlocking();
-	}
-
-	@Override
-	protected void damageArmor(float pDamage) {
-		maidInventory.damageArmor(pDamage);
-		maidAvatar.damageArmor(pDamage);
-	}
-
-	@Override
-	public int getTotalArmorValue() {
-		return maidAvatar.getTotalArmorValue();
-	}
-
-	@Override
-	protected float applyArmorCalculations(DamageSource par1DamageSource, float par2) {
-		return maidAvatar.applyArmorCalculations(par1DamageSource, par2);
-	}
-
-	@Override
-	protected float applyPotionDamageCalculations(DamageSource par1DamageSource, float par2) {
-		return maidAvatar.applyPotionDamageCalculations(par1DamageSource, par2);
-	}
-
-	@Override
-	protected void damageEntity(DamageSource par1DamageSource, float par2) {
-		// ダメージソースに応じて音声変更
-		if (par1DamageSource == DamageSource.fall) {
-			maidDamegeSound = LMM_EnumSound.hurt_fall;
-		}
-		if(!par1DamageSource.isUnblockable() && isBlocking()) {
-			// ブロッキング
-//			par2 = (1.0F + par2) * 0.5F;
-			LMM_LittleMaidMobX.Debug(String.format("Blocking success ID:%d, %f -> %f" , this.getEntityId(), par2, (par2 = (1.0F + par2) * 0.5F)));
-			maidDamegeSound = LMM_EnumSound.hurt_guard;
-		}
-		
-		// 被ダメ
-		float llasthealth = getHealth();
-		if (par2 > 0 && getActiveModeClass() != null && !getActiveModeClass().damageEntity(maidMode, par1DamageSource, par2)) {
-			maidAvatar.damageEntity(par1DamageSource, par2);
-			
-			// ダメージを受けると待機を解除
-			setMaidWait(false);
-		}
-		
-		if (llasthealth == getHealth() && maidDamegeSound == LMM_EnumSound.hurt) {
-			maidDamegeSound = LMM_EnumSound.hurt_nodamege;
-		}
-		LMM_LittleMaidMobX.Debug(String.format("GetDamage ID:%d, %s, %f/ %f" , this.getEntityId(), par1DamageSource.damageType, llasthealth - getHealth(), par2));
-//		super.damageEntity(par1DamageSource, par2);
-	}
-
-	@Override
-	public boolean attackEntityFrom(DamageSource par1DamageSource, float par2) {
-		Entity entity = par1DamageSource.getEntity();
-		
-		if(par1DamageSource.getDamageType().equalsIgnoreCase("thrown"))
-		{
-			if(entity!=null && this.maidAvatar!=null && entity.getEntityId()==this.maidAvatar.getEntityId())
-			{
-				return false;
-			}
-		}
-		
-		LMM_LittleMaidMobX.Debug("LMM_EntityLittleMaid.attackEntityFrom "+this+"("+this.maidAvatar+") <= "+entity);
-		
-		// ダメージソースを特定して音声の設定
-		maidDamegeSound = LMM_EnumSound.hurt;
-		if (par1DamageSource == DamageSource.inFire || par1DamageSource == DamageSource.onFire || par1DamageSource == DamageSource.lava) {
-			maidDamegeSound = LMM_EnumSound.hurt_fire;
-		}
-		for (LMM_EntityModeBase lm : maidEntityModeList) {
-			float li = lm.attackEntityFrom(par1DamageSource, par2);
-			if (li > 0) return li == 1 ? false : true;
-		}
-		
-		setMaidWait(false);
-		setMaidWaitCount(0);
-		if (par2 > 0) {
-			// 遊びは終わりだ！
-			setPlayingRole(0);
-			getNextEquipItem();
-		}
-		// ゲーム難易度によるダメージの補正
-		if(isContract() && (entity instanceof EntityLivingBase) || (entity instanceof EntityArrow)) {
-			if(worldObj.difficultySetting == EnumDifficulty.PEACEFUL) {
-				par2 = 0;
-			}
-			if(worldObj.difficultySetting == EnumDifficulty.EASY && par2 > 0) {
-				par2 = par2 / 2 + 1;
-			}
-			if(worldObj.difficultySetting == EnumDifficulty.HARD) {
-				par2 = (par2 * 3) / 2;
-			}
-		}
-		
-//		if (par2 == 0 && maidMode != mmode_Detonator) {
-		if (par2 == 0) {
-			// ノーダメージ
-			if (maidDamegeSound == LMM_EnumSound.hurt) {
-				maidDamegeSound = LMM_EnumSound.hurt_nodamege;
-			}
-			playSound(maidDamegeSound, true);
-			return false;
-		}
-		
-		if(super.attackEntityFrom(par1DamageSource, par2)) {
-			//契約者の名前チェックはマルチ用
-			if (isContract() && entity != null) {
-				if (getIFF(entity) && !isPlaying()) {
-					fleeingTick = 0;
-					return true;
-				}
-			} else if (maidInventory.getCurrentItem() == null) {
-				return true;
-			}
-			fleeingTick = 0;
-//			entityToAttack = entity;
-			/*
-			if (entity != null) {
-				setPathToEntity(worldObj.getPathEntityToEntity(this, entityToAttack, 16F, true, false, false, true));
-			}
-			if (maidMode == mmode_Healer && entity instanceof EntityLiving) {
-				// ヒーラーは薬剤で攻撃
-				maidInventory.currentItem = maidInventory.getInventorySlotContainItemPotion(true, 0, ((EntityLiving)entity).isEntityUndead() & isMaskedMaid);
-			}
-			*/
-			return true; 
-		} else {
-			return false;
-		}
-		
-		
-//		return maidAvatar.attackEntityFrom(par1DamageSource, par2);
-	}
-
-	/**
-	 * 対象にポーションを使う。
-	 */
-	public void usePotionTotarget(EntityLivingBase entityliving) {
-		ItemStack itemstack = maidInventory.getCurrentItem();
-		if (itemstack != null && itemstack.getItem() instanceof ItemPotion) {
-			// ポーション効果の発動
-			itemstack.stackSize--;
-			List list = ((ItemPotion)itemstack.getItem()).getEffects(itemstack);
-			if (list != null) {
-				PotionEffect potioneffect;
-				for (Iterator iterator = list.iterator(); iterator.hasNext(); entityliving.addPotionEffect(new PotionEffect(potioneffect))) {
-					potioneffect = (PotionEffect)iterator.next();
-				}
-			}
-			if(itemstack.stackSize <= 0) {
-				maidInventory.setInventoryCurrentSlotContents(null);
-			}
-			maidInventory.addItemStackToInventory(new ItemStack(Items.glass_bottle));
-		}
-	}
-
-	@Override
-	protected void dropFewItems(boolean par1, int par2) {
-		// メイドさんはお砂糖とココアと不定形の何かでできてるの！
-		int k = rand.nextInt(3 + par2);
-		for(int j = 0; j <= k; j++) {
-			if(rand.nextInt(30) == 0) {
-				dropItem(Items.slime_ball, 1);
-			}
-			if(rand.nextInt(50) == 0) {
-				entityDropItem(new ItemStack(Items.dye, 1, 3), 0F);
-			}
-			dropItem(Items.sugar, 1);
-		}
-		
-		// インベントリをブチマケロ！
-		maidInventory.dropAllItems();
-	}
-
-	@Override
-	protected Item getDropItem() {
-		return Items.sugar;
-	}
-
-	@Override
-	public int getExperiencePoints(EntityPlayer par1EntityPlayer) {
-		return experienceValue;
-	}
-
-
-	@Override
-	public void applyEntityCollision(Entity par1Entity) {
-		// 閉所接触回避用
-		super.applyEntityCollision(par1Entity);
-		
-		if (par1Entity instanceof LMM_EntityLittleMaid) {
-			if (((LMM_EntityLittleMaid)par1Entity).aiAvoidPlayer.isActive) {
-				aiAvoidPlayer.isActive = true;
-			}
-		} else if (par1Entity == mstatMasterEntity) {
-			aiAvoidPlayer.setActive();
-		}
-	}
-
-	@Override
-	protected void updateAITick() {
-//		// AI対応型はこっちが呼ばれる
-//		dataWatcher.updateObject(dataWatch_Health, Integer.valueOf(getHealth()));
-		
-		// 追加分
-		for (LMM_EntityModeBase ieml : maidEntityModeList) {
-			ieml.updateAITick(getMaidModeInt());
-		}
-	}
-	public void updateAITasks()
-	{
-		super.updateAITasks();
-	}
-
-	@Override
-	public void onEntityUpdate() {
-		super.onEntityUpdate();
-	}
-
-	/**
-	 * 埋葬対策コピー
-	 */
-	private boolean isBlockTranslucent(int par1, int par2, int par3) {
-		return this.worldObj.getBlock(par1, par2, par3).isNormalCube();
-	}
-
-	/**
-	 * 埋葬対策コピー
-	 */
-	@Override
-	protected boolean func_145771_j(double par1, double par3, double par5)
-	{
-		return pushOutOfBlocks(par1, par3, par5);
-	}
-	protected boolean pushOutOfBlocks(double par1, double par3, double par5) {
-		// EntityPlayerSPのを引っ張ってきた
-		int var7 = MathHelper.floor_double(par1);
-		int var8 = MathHelper.floor_double(par3);
-		int var9 = MathHelper.floor_double(par5);
-		double var10 = par1 - (double)var7;
-		double var12 = par5 - (double)var9;
-		
-		boolean lflag = false;
-		for (int li = 0; (float)li < height; li++) {
-			lflag |= this.isBlockTranslucent(var7, var8 + li, var9);
-		}
-		if (lflag) {
-			boolean var14 = !this.isBlockTranslucent(var7 - 1, var8, var9) && !this.isBlockTranslucent(var7 - 1, var8 + 1, var9);
-			boolean var15 = !this.isBlockTranslucent(var7 + 1, var8, var9) && !this.isBlockTranslucent(var7 + 1, var8 + 1, var9);
-			boolean var16 = !this.isBlockTranslucent(var7, var8, var9 - 1) && !this.isBlockTranslucent(var7, var8 + 1, var9 - 1);
-			boolean var17 = !this.isBlockTranslucent(var7, var8, var9 + 1) && !this.isBlockTranslucent(var7, var8 + 1, var9 + 1);
-			byte var18 = -1;
-			double var19 = 9999.0D;
-			
-			if (var14 && var10 < var19) {
-				var19 = var10;
-				var18 = 0;
-			}
-			
-			if (var15 && 1.0D - var10 < var19) {
-				var19 = 1.0D - var10;
-				var18 = 1;
-			}
-			
-			if (var16 && var12 < var19) {
-				var19 = var12;
-				var18 = 4;
-			}
-			
-			if (var17 && 1.0D - var12 < var19) {
-				var19 = 1.0D - var12;
-				var18 = 5;
-			}
-			
-			float var21 = 0.1F;
-			
-			if (var18 == 0) {
-				this.motionX = (double)(-var21);
-			}
-			
-			if (var18 == 1) {
-				this.motionX = (double)var21;
-			}
-			
-			if (var18 == 4) {
-				this.motionZ = (double)(-var21);
-			}
-			
-			if (var18 == 5) {
-				this.motionZ = (double)var21;
-			}
-			
-			return !(var14 | var15 | var16 | var17);
-		}
-		
-		return false;
-	}
-
-	@Override
-	public void onLivingUpdate() {
-		// 回復判定
-		float lhealth = getHealth();
-		if (lhealth > 0) {
-			if (!worldObj.isRemote) {
-				if (getSwingStatusDominant().canAttack()) {
-					if (!isBloodsuck()) {
-						// 通常時は回復優先
-						if (lhealth < getMaxHealth()) {
-							if (maidInventory.consumeInventoryItem(Items.sugar)) {
-								eatSugar(true, false);
-							}
-						}
-					}
-				}
-			}
-		}
-		
-		super.onLivingUpdate();
-		
-		maidInventory.decrementAnimations();
-		// 埋葬対策
-		boolean grave = true;
-		grave &= pushOutOfBlocks(posX - (double)width * 0.34999999999999998D, boundingBox.minY, posZ + (double)width * 0.34999999999999998D);
-		grave &= pushOutOfBlocks(posX - (double)width * 0.34999999999999998D, boundingBox.minY, posZ - (double)width * 0.34999999999999998D);
-		grave &= pushOutOfBlocks(posX + (double)width * 0.34999999999999998D, boundingBox.minY, posZ - (double)width * 0.34999999999999998D);
-		grave &= pushOutOfBlocks(posX + (double)width * 0.34999999999999998D, boundingBox.minY, posZ + (double)width * 0.34999999999999998D);
-		if (grave && onGround) {
-			jump();
-		}
-		if(lhealth > 0) {
-			// 近接監視の追加はここ
-			// アイテムの回収
-			if (!worldObj.isRemote) {
-				List list = worldObj.getEntitiesWithinAABBExcludingEntity(this, boundingBox.expand(1.0D, 0.0D, 1.0D));
-				if (list != null) {
-					for (int i = 0; i < list.size(); i++) {
-						Entity entity = (Entity)list.get(i);
-						if (!entity.isDead) {
-							if (entity instanceof EntityArrow) {
-								// 特殊回収
-								((EntityArrow)entity).canBePickedUp = 1;
-							}
-							entity.onCollideWithPlayer(maidAvatar);
-						}
-					}
-					// アイテムが一杯になっていてアイテムにタゲをとっている場合はタゲをクリア
-					if (entityToAttack instanceof EntityItem && maidInventory.getFirstEmptyStack() == -1) {
-						setTarget(null);
-					}
-				}
-			}
-			// 時計を持っている
-			// TODO:多分この辺りの処理はおかしい
-			if (isContractEX() && mstatClockMaid) {
-				// ゲーム内時間に合わせた音声の再生
-				mstatTime = (int)(worldObj.getWorldTime() % 24000);
-				if (mstatMasterEntity != null) {
-					boolean b = mstatMasterEntity.isPlayerSleeping();
-					
-					if (mstatMasterDistanceSq < 25D && getEntitySenses().canSee(mstatMasterEntity))	{
-						LMM_EnumSound lsound = LMM_EnumSound.Null;
-						if (mstatFirstLook && (mstatTime > 23500 || mstatTime < 1500)) {
-							lsound = LMM_EnumSound.goodmorning;
-							mstatFirstLook = false;
-						} 
-						else if (!mstatFirstLook && b) {
-							lsound = LMM_EnumSound.goodnight;
-							mstatFirstLook = true;
-						} 
-						else if (mstatFirstLook && !b) {
-							mstatFirstLook = false;
-						}
-						
-						if (lsound != LMM_EnumSound.Null) {
-							playSound(lsound, true);
-							setLooksWithInterest(true);
-						}
-					} else {
-						if (!mstatFirstLook && (b || (mstatTime > 18000 && mstatTime < 23500))) {
-							mstatFirstLook = true;
-						}
-					}
-				}
-			} else {
-				mstatTime = 6000;
-			}
-			
-			// TNT-D System
-			maidOverDriveTime.onUpdate();
-			if (maidOverDriveTime.isDelay()) {
-				for (int li = 0; li < mstatSwingStatus.length; li++) {
-					mstatSwingStatus[li].attackTime--;
-				}
-				if (maidOverDriveTime.isEnable()) {
-					worldObj.spawnParticle("reddust", (posX + (double)(rand.nextFloat() * width * 2.0F)) - (double)width, posY + 0.5D + (double)(rand.nextFloat() * height), (posZ + (double)(rand.nextFloat() * width * 2.0F)) - (double)width, 1.2D, 0.4D, 0.4D);
-				}
-				if (!worldObj.isRemote) {
-					Entity lattackentity = getAttackTarget();
-					if (lattackentity == null) {
-						lattackentity = getEntityToAttack();
-					}
-					if (lattackentity != null) {
-						PathEntity pe = worldObj.getPathEntityToEntity(this, lattackentity, 16F, true, false, false, true);
-						
-						if (pe != null) {
-							pe.incrementPathIndex();
-							if (!pe.isFinished()) {
-								Vec3 v = pe.getPosition(this);
-								setPosition(v.xCoord, v.yCoord, v.zCoord);
-							}
-						}
-					}
-				}
-			}
-			
-			if (!worldObj.isRemote) {
-				if (getSwingStatusDominant().canAttack()) {
-//					mod_LMM_littleMaidMob.Debug("isRemort:" + worldObj.isRemote);
-					// 回復
-					if (getHealth() < getMaxHealth()) {
-						if (maidInventory.consumeInventoryItem(Items.sugar)) {
-							eatSugar(true, false);
-						}
-					}
-					// つまみ食い
-					if (rand.nextInt(50000) == 0 && maidInventory.consumeInventoryItem(Items.sugar)) {
-						eatSugar(true, false);
-					}
-					// 契約更新
-					if (isContractEX()) {
-						float f = getContractLimitDays();
-						if (f <= 6 && maidInventory.consumeInventoryItem(Items.sugar)) {
-							// 契約更新
-							eatSugar(true, true);
-						}
-					}
-				}
-			}
-		}
-	}
-
-	@Override
-	public void onUpdate() {
-		int litemuse = 0;
-		
-		// Entity初回生成時のインベントリ更新用
-		// サーバーの方が先に起動するのでクライアント側が更新を受け取れない
-		if (firstload > 0) {
-			// 初回更新用
-			// サーバーの方が先に起動しているので強制読み込みの手順が必要
-			if (--firstload == 0) {
-				if (worldObj.isRemote) {
-					LMM_Net.sendToEServer(this, new byte[] {LMM_Statics.LMN_Server_UpdateSlots, 0, 0, 0, 0});
-				} else {
-				}
-			}
-		}
-		
-		// 飛び道具用
-		weaponFullAuto = false;
-		weaponReload = false;
-		
-		// 主の確認など
-		mstatMasterEntity = getMaidMasterEntity();
-		if (mstatMasterEntity != null) {
-			mstatMasterDistanceSq = getDistanceSqToEntity(mstatMasterEntity);
-		}
-		// モデルサイズのリアルタイム変更有り？
-		textureData.onUpdate();
-		// リアルタイム変動値をアップデート
-		if (worldObj.isRemote) {
-			// クライアント側
-			boolean lupd = false;
-			lupd |= updateMaidContract();
-			lupd |= updateMaidColor();
-//			lupd |= updateTexturePack();
-			updateTexturePack();
-			if (lupd) {
-				setTextureNames();
-			}
-			setMaidMode(dataWatcher.getWatchableObjectShort(dataWatch_Mode));
-			setDominantArm(dataWatcher.getWatchableObjectByte(dataWatch_DominamtArm));
-			updateMaidFlagsClient();
-			updateGotcha();
-			
-			// 腕の挙動関連
-			litemuse = dataWatcher.getWatchableObjectInt(dataWatch_ItemUse);
-			for (int li = 0; li < mstatSwingStatus.length; li++) {
-				ItemStack lis = mstatSwingStatus[li].getItemStack(this);
-				if ((litemuse & (1 << li)) > 0 && lis != null) {
-					mstatSwingStatus[li].setItemInUse(lis, lis.getMaxItemUseDuration(), this);
-				} else {
-					mstatSwingStatus[li].stopUsingItem(this);
-				}
-			}
-		} else {
-			boolean lf;
-			// サーバー側
-			updateRemainsContract();
-			// Overdrive
-			lf = maidOverDriveTime.isEnable();
-			if (getMaidFlags(dataWatch_Flags_OverDrive) != lf) {
-				if (lf) {
-					playSound(LMM_EnumSound.TNT_D, true);
-				}
-				setMaidFlags(lf, dataWatch_Flags_OverDrive);
-			}
-			// Working!
-			lf = mstatWorkingCount.isEnable();
-			if (getMaidFlags(dataWatch_Flags_Working) != lf) {
-				setMaidFlags(lf, dataWatch_Flags_Working);
-			}
-			// 拗ねる
-			if (!isContractEX() && !isFreedom()) {
-				setFreedom(true);
-				setMaidWait(false);
-			}
-			// 移動速度の変更
-			IAttributeInstance latt = this.getEntityAttribute(SharedMonsterAttributes.movementSpeed);
-			// 属性を解除
-			latt.removeModifier(attCombatSpeed);
-			if (isContract()) {
-				if (!isFreedom() || (entityToAttack != null || getAttackTarget() != null)) {
-					// 属性を設定
-					latt.applyModifier(attCombatSpeed);
-				}
-			}
-			// スニーキング判定
-			latt.removeModifier(attSneakingSpeed);
-			if ((onGround && isSneaking()) || isUsingItem()) {
-				latt.applyModifier(attSneakingSpeed);
-			}
-//			isSprinting()
-		}
-		
-		// 独自処理用毎時処理
-		for (LMM_EntityModeBase leb : maidEntityModeList) {
-			leb.onUpdate(maidMode);
-		}
-		
-		
-		super.onUpdate();
-		// SwingUpdate
-		LMM_SwingStatus lmss1 = getSwingStatusDominant();
-		prevSwingProgress = maidAvatar.prevSwingProgress = lmss1.prevSwingProgress;
-		swingProgress = maidAvatar.swingProgress = lmss1.swingProgress;
-		swingProgressInt = maidAvatar.swingProgressInt = lmss1.swingProgressInt;
-		isSwingInProgress = maidAvatar.isSwingInProgress = lmss1.isSwingInProgress;
-		
-		// Aveterの毎時処理
-		if (maidAvatar != null) {
-			maidAvatar.getValue();
-			maidAvatar.onUpdate();
-//			maidAvatar.setValue();
-		}
-		
-		// カウンタ系
-		if (mstatWaitCount > 0) {
-			if (hasPath()) {
-				mstatWaitCount = 0;
-			} else {
-				mstatWaitCount--;
-			}
-		}
-		if (maidSoundInterval > 0) {
-			maidSoundInterval--;
-		}
-		
-		// くびかしげ	
-		prevRotateAngleHead = rotateAngleHead;
-		if (getLooksWithInterest()) {
-			rotateAngleHead = rotateAngleHead + (1.0F - rotateAngleHead) * 0.4F;
-			numTicksToChaseTarget = 10;
-		} else {
-			rotateAngleHead = rotateAngleHead + (0.0F - rotateAngleHead) * 0.4F;
-			if (numTicksToChaseTarget > 0) numTicksToChaseTarget--;
-		}
-		
-		if (getAttackTarget() != null || getEntityToAttack() != null) {
-			setWorking(true);
-		}
-		// お仕事カウンター
-		mstatWorkingCount.onUpdate();
-		
-		// 腕の挙動に関する処理
-		litemuse = 0;
-		for (int li = 0; li < mstatSwingStatus.length; li++) {
-			mstatSwingStatus[li].onUpdate(this);
-			if (mstatSwingStatus[li].isUsingItem()) {
-				litemuse |= (1 << li);
-			}
-		}
-		// 標準変数に対する数値の代入
-		LMM_SwingStatus lmss = getSwingStatusDominant();
-		prevSwingProgress = maidAvatar.prevSwingProgress = lmss.prevSwingProgress;
-		swingProgress = maidAvatar.swingProgress = lmss.swingProgress;
-		swingProgressInt = maidAvatar.swingProgressInt = lmss.swingProgressInt;
-		isSwingInProgress = maidAvatar.isSwingInProgress = lmss.isSwingInProgress;
-		
-		// 持ち物の確認
-		if (maidInventory.inventoryChanged) {
-			onInventoryChanged();
-			maidInventory.inventoryChanged = false;
-		}
-		if (!worldObj.isRemote) {
-			// サーバー側処理
-			// アイテム使用状態の更新
-			dataWatcher.updateObject(dataWatch_ItemUse, litemuse);
-			// インベントリの更新
-//			if (!mstatOpenInventory) {
-				for (int li = 0 ;li < maidInventory.getSizeInventory(); li++) {
-					boolean lchange = false;
-					int lselect = 0xff;
-					// 選択装備が変わった
-					for (int lj = 0; lj < mstatSwingStatus.length; lj++) {
-						lchange = mstatSwingStatus[lj].checkChanged();
-						if (mstatSwingStatus[lj].index == li) {
-							lselect = lj;
-						}
-					}
-					// インベントリの中身が変わった
-					if (lchange || maidInventory.isChanged(li)) {
-						((WorldServer)worldObj).getEntityTracker().func_151247_a(this, new S04PacketEntityEquipment(this.getEntityId(), (li | lselect << 8) + 5, maidInventory.getStackInSlot(li)));
-						maidInventory.resetChanged(li);
-						LMM_LittleMaidMobX.Debug(String.format("ID:%d-%s - Slot(%x:%d-%d,%d) Update.", getEntityId(), worldObj.isRemote ? "Client" : "Server", lselect, li, mstatSwingStatus[0].index, mstatSwingStatus[1].index));
-					}
-//				}
-			}
-			
-			// 弓構え
-			mstatAimeBow &= !getSwingStatusDominant().canAttack();
-			// 構えの更新
-			updateAimebow();
-			
-			// TODO:test
-			if (dataWatcher.getWatchableObjectInt(dataWatch_ExpValue) != experienceValue) {
-				dataWatcher.updateObject(dataWatch_ExpValue, Integer.valueOf(experienceValue));
-			}
-			
-			// 自分より大きなものは乗っけない（イカ除く）
-			if (riddenByEntity != null && !(riddenByEntity instanceof EntitySquid)) {
-				if (height * width < riddenByEntity.height * riddenByEntity.width) {
-					if (riddenByEntity instanceof EntityLivingBase) {
-						attackEntityFrom(DamageSource.causeMobDamage((EntityLivingBase)riddenByEntity), 0);
-					}
-					riddenByEntity.mountEntity(null);
-					return;
-				}
-			}
-			
-			// 斧装備時は攻撃力が上がる
-			IAttributeInstance latt = this.getEntityAttribute(SharedMonsterAttributes.attackDamage);
-			// 属性を解除
-			latt.removeModifier(attAxeAmp);
-			ItemStack lis = getCurrentEquippedItem();
-			if (lis != null && lis.getItem() instanceof ItemAxe) {
-				// 属性を設定
-				latt.applyModifier(attAxeAmp);
-			}
-		} else {
-			// Client
-			// TODO:test
-			experienceValue = dataWatcher.getWatchableObjectInt(dataWatch_ExpValue);
-		}
-		
-		// 紐で拉致
-		if(mstatgotcha != null) {
-			double d = mstatgotcha.getDistanceSqToEntity(this);
-			if (entityToAttack == null) {
-				// インコムごっこ用
-				if (d > 4D) {
-//					setPathToEntity(null);
-					getNavigator().clearPathEntity();
-					getLookHelper().setLookPositionWithEntity(mstatgotcha, 15F, 15F);
-				}
-				if (d > 12.25D) {
-//					setPathToEntity(worldObj.getPathEntityToEntity(mstatgotcha, this, 16F, true, false, false, true));
-					getNavigator().tryMoveToXYZ(mstatgotcha.posX, mstatgotcha.posY, mstatgotcha.posZ, 1.0F);
-					getLookHelper().setLookPositionWithEntity(mstatgotcha, 15F, 15F);
-				}
-			}
-			if (d > 25D) {
-				double d1 = mstatgotcha.posX - posX;
-				double d3 = mstatgotcha.posZ - posZ;
-				double d5 = 0.125D / (Math.sqrt(d1 * d1 + d3 * d3) + 0.0625D);
-				d1 *= d5;
-				d3 *= d5;
-				motionX += d1;
-				motionZ += d3;
-			}
-			if (d > 42.25D) {
-				double d2 = mstatgotcha.posX - posX;
-				double d4 = mstatgotcha.posZ - posZ;
-				double d6 = 0.0625D / (Math.sqrt(d2 * d2 + d4 * d4) + 0.0625D);
-				d2 *= d6;
-				d4 *= d6;
-				mstatgotcha.motionX -= d2;
-				mstatgotcha.motionZ -= d4;
-			}
-			if (d > 64D) {
-				setGotcha(0);
-				mstatgotcha = null;
-				playSound("random.drr");
-			}
-			if(rand.nextInt(16) == 0) {
-				List list = worldObj.getEntitiesWithinAABBExcludingEntity(this, boundingBox.expand(8D, 8D, 8D));
-				for (int k = 0; k < list.size(); k++) {
-					Entity entity = (Entity)list.get(k);
-					if (!(entity instanceof EntityMob)) {
-						continue;
-					}
-					EntityMob entitymob = (EntityMob)entity;
-					if (entitymob.getEntityToAttack() == mstatgotcha) {
-						entitymob.setTarget(this);
-					}
-				}
-			}
-		}
-		
-	}
-
-
-	@Override
-	public void onDeath(DamageSource par1DamageSource) {
-		super.onDeath(par1DamageSource);
-		
-		// 死因を表示
-		if (!worldObj.isRemote) {
-			// マスター判定失敗するかも？
-			if (LMM_LittleMaidMobX.cfg_DeathMessage && mstatMasterEntity != null) {
-				String ls = par1DamageSource.getDamageType();
-				Entity lentity = par1DamageSource.getEntity();
-				if (lentity != null) {
-					if (par1DamageSource.getEntity() instanceof EntityPlayer) {
-						ls += ":" + MMM_Helper.getPlayerName((EntityPlayer)lentity);  
-					} else {
-						String lt = EntityList.getEntityString(lentity);
-						if (lt != null) {
-							ls += ":" + lt;
-						}
-					}
-				}
-				
-				// 不具合対応
-				// getFormattedText → getUnformattedTextForChat
-				// getFormattedText はクライアント専用（描画用）。
-				// http://forum.minecraftuser.jp/viewtopic.php?f=13&t=23347&p=212078#p211805
-				String lt = func_145748_c_().getUnformattedTextForChat();
-
-				ChatComponentText text = new ChatComponentText(String.format("your %s killed by %s", lt, ls));
-				mstatMasterEntity.addChatMessage(text);
-			}
-		}
-	}
-
-	// ポーションエフェクト
-	@Override
-	protected void onNewPotionEffect(PotionEffect par1PotionEffect) {
-		super.onNewPotionEffect(par1PotionEffect);
-		if (mstatMasterEntity instanceof EntityPlayerMP) {
-			((EntityPlayerMP)mstatMasterEntity).playerNetServerHandler.sendPacket(new S1DPacketEntityEffect(this.getEntityId(), par1PotionEffect));
-		}
-	}
-
-	@Override
-	protected void onChangedPotionEffect(PotionEffect par1PotionEffect, boolean par2) {
-		super.onChangedPotionEffect(par1PotionEffect, par2);
-		// TODO:必要かどうかのチェック
-//		if (mstatMasterEntity instanceof EntityPlayerMP) {
-//			((EntityPlayerMP)mstatMasterEntity).playerNetServerHandler.sendPacketToPlayer(new Packet41EntityEffect(this.getEntityId(), par1PotionEffect));
-//		}
-	}
-
-	@Override
-	protected void onFinishedPotionEffect(PotionEffect par1PotionEffect) {
-		super.onFinishedPotionEffect(par1PotionEffect);
-		if (mstatMasterEntity instanceof EntityPlayerMP) {
-			((EntityPlayerMP)mstatMasterEntity).playerNetServerHandler.sendPacket(new S1EPacketRemoveEntityEffect(this.getEntityId(), par1PotionEffect));
-		}
-	}
-
-
-
-	/**
-	 *  インベントリが変更されました。
-	 */
-	public void onInventoryChanged() {
-		checkClockMaid();
-		checkMaskedMaid();
-		checkHeadMount();
-		getNextEquipItem();
-//		setArmorTextureValue();
-	}
-
-	/**
-	 * インベントリにある次の装備品を選択
-	 */
-	public boolean getNextEquipItem() {
-		if (worldObj.isRemote) {
-			// クライアント側は処理しない
-			return false;
-		}
-		
-		int li;
-		if (isActiveModeClass()) {
-			li = getActiveModeClass().getNextEquipItem(maidMode);
-		} else {
-			li = -1;
-		}
-		setEquipItem(maidDominantArm, li);
-		return li > -1; 
-	}
-
-	public void setEquipItem(int pArm, int pIndex) {
-		if (pArm == maidDominantArm) {
-			maidInventory.currentItem = pIndex;
-		}
-		int li = mstatSwingStatus[pArm].index;
-		if (li != pIndex) {
-			if (li > -1) {
-				maidInventory.setChanged(li);
-			}
-			if (pIndex > -1) {
-				maidInventory.setChanged(pIndex);
-			}
-			mstatSwingStatus[pArm].setSlotIndex(pIndex);
-		}
-	}
-	public void setEquipItem(int pIndex) {
-		setEquipItem(maidDominantArm, pIndex);
-	}
-
-
-	/**
-	 * 対応型射撃武器のリロード判定
-	 */
-	public void getWeaponStatus() {
-		// 飛び道具用の特殊処理
-		ItemStack is = maidInventory.getCurrentItem();
-		if (is == null) return;
-		
-		try {
-			Method me = is.getItem().getClass().getMethod("isWeaponReload", ItemStack.class, EntityPlayer.class);
-			weaponReload = (Boolean)me.invoke(is.getItem(), is, maidAvatar);
-		}
-		catch (NoSuchMethodException e) {
-		}
-		catch (Exception e) {
-		}
-		
-		try {
-			Method me = is.getItem().getClass().getMethod("isWeaponFullAuto", ItemStack.class);
-			weaponFullAuto = (Boolean)me.invoke(is.getItem(), is);
-		}
-		catch (NoSuchMethodException e) {
-		}
-		catch (Exception e) {
-		}
-	}
-
-	// 保持アイテム関連
-
-	/**
-	 * 現在の装備品
-	 */
-	public ItemStack getCurrentEquippedItem() {
-		return maidInventory.getCurrentItem();
-	}
-	@Override
-	public ItemStack getHeldItem() {
-		return maidInventory.getCurrentItem();
-	}
-
-	@Override
-	public ItemStack getEquipmentInSlot(int par1) {
-		if (par1 == 0) {
-			return getHeldItem();
-		} else if (par1 < 5) {
-			return maidInventory.armorItemInSlot(par1 - 1);
-		} else {
-			return maidInventory.getStackInSlot(par1 - 5);
-		}
-	}
-
-	@Override
-	public ItemStack func_130225_q(int par1) {
-		return maidInventory.armorItemInSlot(par1);
-	}
-
-	@Override
-	public void setCurrentItemOrArmor(int par1, ItemStack par2ItemStack) {
-		par1 &= 0x0000ffff;
-		if (par1 == 0) {
-			maidInventory.setInventoryCurrentSlotContents(par2ItemStack);
-		} else if (par1 > 0 && par1 < 4) {
-			maidInventory.armorInventory[par1 - 1] = par2ItemStack;
-			setTextureNames();
-		} else if (par1 == 4) {
-//			maidInventory.mainInventory[mstatMaskSelect] = mstatMaskSelect > -1 ? par2ItemStack : null;
-			if (mstatMaskSelect > -1) {
-				maidInventory.mainInventory[mstatMaskSelect] = par2ItemStack;
-			}
-			setTextureNames();
-		} else {
-			par1 -= 5;
-			// 持ち物のアップデート
-			// 独自拡張:普通にスロット番号の通り、上位８ビットは装備スロット
-			// par1はShortで渡されるのでそのように。
-			int lslotindex = par1 & 0x7f;
-			int lequip = (par1 >>> 8) & 0xff;
-			maidInventory.setInventorySlotContents(lslotindex, par2ItemStack);
-			maidInventory.resetChanged(lslotindex);	// これは意味ないけどな。
-			maidInventory.inventoryChanged = true;
-//			if (par1 >= maidInventory.mainInventory.length) {
-//				LMM_Client.setArmorTextureValue(this);
-//			}
-
-			for (LMM_SwingStatus lss: mstatSwingStatus) {
-				if (lslotindex == lss.index) {
-					lss.index = -1;
-				}
-			}
-			if (lequip != 0xff) {
-				setEquipItem(lequip, lslotindex);
-//				mstatSwingStatus[lequip].index = lslotindex;
-			}
-			if (lslotindex >= maidInventory.maxInventorySize) {
-				setTextureNames();
-			}
-			String s = par2ItemStack == null ? null : par2ItemStack.getDisplayName();
-			LMM_LittleMaidMobX.Debug(String.format("ID:%d Slot(%2d:%d):%s", getEntityId(), lslotindex, lequip, s == null ? "NoItem" : s));
-		}
-	}
-
-	@Override
-	public ItemStack[] getLastActiveItems() {
-		return maidInventory.armorInventory;
-	}
-
-	protected void checkClockMaid() {
-		// 時計を持っているか？
-		mstatClockMaid = maidInventory.getInventorySlotContainItem(Items.clock) > -1;
-	}
-	/**
-	 * 時計を持っているか?
-	 */
-	public boolean isClockMaid() {
-		return mstatClockMaid;
-	}
-
-	protected void checkMaskedMaid() {
-		// インベントリにヘルムがあるか？
-		for (int i = maidInventory.mainInventory.length - 1; i >= 0; i--) {
-			ItemStack is = maidInventory.getStackInSlot(i);
-			if (is != null && is.getItem() instanceof ItemArmor && ((ItemArmor)is.getItem()).armorType == 0) {
-				// ヘルムを持ってる
-				mstatMaskSelect = i;
-				maidInventory.armorInventory[3] = is;
-				if (worldObj.isRemote) {
-					setTextureNames();
-				}
-				return;
-			}
-		}
-		
-		mstatMaskSelect = -1;
-		maidInventory.armorInventory[3] = null;
-		return;
-	}
-	/**
-	 * メットを被ってるか 
-	 */
-	public boolean isMaskedMaid() {
-		return mstatMaskSelect > -1;
-	}
-
-	protected void checkHeadMount() {
-		// 追加の頭部装備の判定
-		ItemStack lis = maidInventory.getHeadMount();
-		mstatPlanter = false;
-		mstatCamouflage = false;
-		if (lis != null) {
-			if (lis.getItem() instanceof ItemBlock) {
-				Block lblock = Block.getBlockFromItem(lis.getItem());
-//				mstatPlanter =	(lblock instanceof BlockFlower      && lblock.getRenderType() ==  1) ||
-				mstatPlanter =	(lblock.getRenderType() ==  1) ||
-								(lblock instanceof BlockDoublePlant && lblock.getRenderType() == 40);
-				mstatCamouflage = (lblock instanceof BlockLeaves) || (lblock instanceof BlockPumpkin) || (lblock instanceof BlockStainedGlass);
-			} else if (lis.getItem() instanceof ItemSkull) {
-				mstatCamouflage = true;
-			}
-		}		
-	}
-	/**
-	 * カモフラージュ！ 
-	 */
-	public boolean isCamouflage() {
-		return mstatCamouflage;
-	}
-	/**
-	 * 鉢植え状態 
-	 */
-	public boolean isPlanter() {
-		return mstatPlanter;
-	}
-
-	/**
-	 * ポーション等による腕振りモーションの速度補正
-	 */
-	public int getSwingSpeedModifier() {
-		if (isPotionActive(Potion.digSpeed)) {
-			return 6 - (1 + getActivePotionEffect(Potion.digSpeed).getAmplifier()) * 1;
-		}
-		
-		if (isPotionActive(Potion.digSlowdown)) {
-			return 6 + (1 + getActivePotionEffect(Potion.digSlowdown).getAmplifier()) * 2;
-		} else {
-			return 6;
-		}
-	}
-
-	/**
-	 * 手持ちアイテムの破壊
-	 */
-	public void destroyCurrentEquippedItem() {
-		maidInventory.setInventoryCurrentSlotContents(null);
-	}
-
-	/**
-	 * メイドインベントリを開く
-	 * @param pEntityPlayer
-	 */
-	public void displayGUIMaidInventory(EntityPlayer pEntityPlayer) {
-		if (!worldObj.isRemote) {
-			LMM_GuiCommonHandler.maidServer = this;
-			pEntityPlayer.openGui(LMM_LittleMaidMobX.instance, LMM_GuiCommonHandler.GUI_ID_INVVENTORY, this.worldObj,
-					(int)this.posX, (int)this.posY, (int)this.posZ);
-		}
-		else
-		{
-			LMM_GuiCommonHandler.maidClient = this;
-		}
-	}
-
-	@Override
-	public boolean interact(EntityPlayer par1EntityPlayer)
-	{
-		LMM_LittleMaidMobX.Debug(this.worldObj.isRemote, "LMM_EntityLittleMaid.interact:"+par1EntityPlayer.getGameProfile().getName());
-		float lhealth = getHealth();
-		ItemStack itemstack1 = par1EntityPlayer.getCurrentEquippedItem();
-		
-		// プラグインでの処理を先に行う
-		for (int li = 0; li < maidEntityModeList.size(); li++) {
-			if (maidEntityModeList.get(li).preInteract(par1EntityPlayer, itemstack1)) {
-				return true;
-			}
-		}
-		// しゃがみ時は処理無効
-		if (par1EntityPlayer.isSneaking()) {
-			return false;
-		}
-		// ナデリ判定
-		if (lhealth > 0F && par1EntityPlayer.riddenByEntity != null && !(par1EntityPlayer.riddenByEntity instanceof LMM_EntityLittleMaid)) {
-			// 載せ替え
-			par1EntityPlayer.riddenByEntity.mountEntity(this);
-			return true;
-		}
-		
-		
-		
-		if (mstatgotcha == null && par1EntityPlayer.fishEntity == null) {
-			if(itemstack1 != null && itemstack1.getItem() == Items.string) {
-				// 紐で繋ぐ
-				setGotcha(par1EntityPlayer.getEntityId());
-				mstatgotcha = par1EntityPlayer;
-				MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, 1);
-				playSound("random.pop");
-				return true;
-			} 
-			
-			if (isContract()) {
-				// 契約状態
-				if (lhealth > 0F && isMaidContractOwner(par1EntityPlayer)) {
-					if (itemstack1 != null) {
-						// 追加分の処理
-						setPathToEntity(null);
-						// プラグインでの処理を先に行う
-						for (int li = 0; li < maidEntityModeList.size(); li++) {
-							if (maidEntityModeList.get(li).interact(par1EntityPlayer, itemstack1)) {
-								return true;
-							}
-						}
-						if (isRemainsContract()) {
-							// 通常
-							if (itemstack1.getItem() == Items.sugar) {
-								// モード切替
-								MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, 1);
-								eatSugar(false, true);
-								worldObj.setEntityState(this, (byte)11);
-								
-								LMM_LittleMaidMobX.Debug("give suger." + worldObj.isRemote);
-								if (!worldObj.isRemote) {
-									setFreedom(isFreedom());
-									if (isMaidWait()) {
-										// 動作モードの切替
-										boolean lflag = false;
-										setActiveModeClass(null);
-										for (int li = 0; li < maidEntityModeList.size() && !lflag; li++) {
-											lflag = maidEntityModeList.get(li).changeMode(par1EntityPlayer);
-											if (lflag) {
-												setActiveModeClass(maidEntityModeList.get(li));
-											}
-										}
-										if (!lflag) {
-											setMaidMode("Escorter");
-											setEquipItem(-1);
-//											maidInventory.currentItem = -1;
-										}
-										setMaidWait(false);
-										getNextEquipItem();
-									} else {
-										// 待機
-										setMaidWait(true);
-									}
-								}
-								return true;
-							}
-							else if (itemstack1.getItem() == Items.dye) {
-								// カラーメイド
-								if (!worldObj.isRemote) {
-									setColor(15 - itemstack1.getItemDamage());
-								}
-								MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, 1);
-								return true;
-							}
-							else if (itemstack1.getItem() == Items.feather) {
-								// 自由行動
-								MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, 1);
-								setFreedom(!isFreedom());
-								worldObj.setEntityState(this, isFreedom() ? (byte)12 : (byte)13);
-								return true;
-							}
-							else if (itemstack1.getItem() == Items.saddle) {
-								// 肩車
-								if (!worldObj.isRemote) {
-									if (ridingEntity == par1EntityPlayer) {
-										this.mountEntity(null);
-									} else {
-										this.mountEntity(par1EntityPlayer);
-									}
-									return true;
-								}
-							}
-							else if (itemstack1.getItem() == Items.gunpowder) {
-								// test TNT-D
-//								playSound(LMM_EnumSound.eatGunpowder, false);
-								maidOverDriveTime.setValue(itemstack1.stackSize * 10);
-								MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, itemstack1.stackSize);
-								return true;
-							}
-							else if (itemstack1.getItem() == Items.book) {
-								// IFFのオープン
-								MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, 1);
-								if (worldObj.isRemote) {
-									par1EntityPlayer.openGui(LMM_LittleMaidMobX.instance,
-											LMM_GuiCommonHandler.GUI_ID_IFF,
-											this.worldObj,
-											(int)this.posX,
-											(int)this.posY,
-											(int)this.posZ);
-								}
-								return true;
-							}
-							else if ((itemstack1.getItem() == Items.glass_bottle) && (experienceValue >= 5)) {
-								// Expボトル
-								MMM_Helper.decPlayerInventory(par1EntityPlayer, -1, 1);
-								if (!worldObj.isRemote) {
-									entityDropItem(new ItemStack(Items.experience_bottle), 0.5F);
-									experienceValue -= 5;
-									if (maidAvatar != null) {
-										maidAvatar.experienceTotal -= 5;
-									}
-								}
-								return true;
-							}
-							else if (itemstack1.getItem() instanceof ItemPotion) {
-								// ポーション
-								if(!worldObj.isRemote) {
-									List list = ((ItemPotion)itemstack1.getItem()).getEffects(itemstack1);
-									if (list != null) {
-										PotionEffect potioneffect;
-										for (Iterator iterator = list.iterator(); iterator.hasNext();